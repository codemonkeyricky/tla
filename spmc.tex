% \begin{document}

\chapter{SPMC Lockless Queue}

As the name suggest, a SPMC lockless queue supports a single producer multiple
consumer usage topology.\newline

In previously described SPSC, the reader assumes write index is reserved, and
the writer assumes read index is reserved. While the relationship between read
and write context remains true in SPMC, the complication is now readers compete
to reserve an index during read. Some design considerations include:
\begin{itemize}
    \item Readers must have a way to reserve an index to read
    \item Readers may complete the read in order different from when they reserve the indices 
    \item Readers can perform the reads independently
\end{itemize}

A primitive in modern CPU architecture is the compare-and-swap (CAS)
instruction. To use CAS, issuer needs to specify a memory location, a current
value and a new value. Only when value in the memory location matches the
current value, the new value will be writen. The instruction ensure this is done
atomically. If multiple CPUs issue CAS at the same time to the same memory
location, only one CPU will \textit{win} as the other CPU's current value check
will fail. Many of the concurrent algorithms are built ontop of this primitive. 

\section{Design}

Some of the design limitation include:
\begin{itemize}
    \item A resource is exclusively updated by one owner, and read by one or more readers
    \item For shared resource that can be updated by multiple owners, the CPU
    can gaurantees exclusive update from a single resource 
\end{itemize}

For the design:
\begin{itemize}
    \item SPMC is implemented as a circular queue with size of N
    \item The status of indvidual index is represented as an status array of size N
    \item The status of each index is either UNUSED, WRITTEN, or READING
    \item Each reader maintain its own read pointer
    \item A \textit{outstanding} counter is incremented by the writer when write is complete, 
    and decremented by the reader when it reserves a read
\end{itemize}

Whenever the write finishes a write, it increments \textit{outstanding} to
indicate some buffer is ready to read.\newline 

To read, a reader performs a two-step reservation: 
\begin{itemize}
    \item The reader decrements \textit{outstanding}. A successful decrement means
    the reader is \textit{gauranteed} a read index.
    \item After successful decrement of \textit{outstanding}, the reader walk
    its read pointer until it successfully reserve the next available index to
    read. A This is done by attempting to CAS update an index from WRITTEN to
    READING. If the update fails, then the index was already reserved by another 
    reader.
\end{itemize}

There may be more than one approach in implementing SPMC, the above description
is what we will implement in this chapter.

% \subsection{Side Note}

% I initially started with a three pointer approach: r, rnxt, w. r to rnxt being 
% the range of indicies where one or more reader may be actively reading, and rnxt
% being the next element available to read. The challenge was in the case fo 
% multiple reader competing to reserve rnext, 

% A complication with the 

% A complication in the design is writer's queue full check. In SPSC, when write
% pointer catches up to read pointer, the queue is full. In SPMC with multiple
% readers, the writer will need to check \textit{all} read pointer. Adding a 
% separate \textit{outstanding} counter simplifies the design. 

\section{Spec}

The following is the core reader implementation:
\newline
\begin{pcal}
procedure reader() 
variable 
    i = self;
begin
r_chk_empty:        
    if outstanding # 0 then 
        outstanding := outstanding - 1; 
    else 
    r_early_ret:            
        return;
    end if;
r_try_lock:         
    if status[rptr[i]] = WRITTEN then 
        status[rptr[i]] := READING;
    else 
    r_retry:                
        rptr[i] := (rptr[i] + 1) % N;
            goto r_try_lock;
    end if;
r_data_chk:         
    assert buffer[rptr[i]] = rptr[i] + 1000;
r_read_buf:         
    buffer[rptr[i]] := 0;
r_unlock:           
    status[rptr[i]] := UNUSED;
r_done:             
    return;
end procedure; 
\end{pcal}
\begin{tlatex}
\@x{ {\p@procedure} reader {\p@lparen} {\p@rparen}}%
\@x{ {\p@variable}}%
\@x{\@s{16.4} i \.{=} self {\p@semicolon}}%
\@x{ {\p@begin}}%
\@x{ r\_chk\_empty\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{16.4} {\p@if} outstanding \.{\neq} 0 {\p@then}}%
\@x{\@s{20.5} outstanding \.{:=} outstanding \.{-} 1 {\p@semicolon}}%
\@x{\@s{16.4} {\p@else}}%
\@x{\@s{16.4} r\_early\_ret\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{32.8} {\p@return} {\p@semicolon}}%
\@x{\@s{16.4} {\p@end} {\p@if} {\p@semicolon}}%
\@x{ r\_try\_lock\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{16.4} {\p@if} status [ rptr [ i ] ] \.{=} WRITTEN {\p@then}}%
\@x{\@s{20.5} status [ rptr [ i ] ] \.{:=} READING {\p@semicolon}}%
\@x{\@s{16.4} {\p@else}}%
\@x{\@s{16.4} r\_retry\@s{.5}\textrm{:}\@s{3}}%
 \@x{\@s{32.8} rptr [ i ] \.{:=} ( rptr [ i ] \.{+} 1 ) \.{\%} N
 {\p@semicolon}}%
\@x{\@s{32.8} {\p@goto} r\_try\_lock {\p@semicolon}}%
\@x{\@s{16.4} {\p@end} {\p@if} {\p@semicolon}}%
\@x{ r\_data\_chk\@s{.5}\textrm{:}\@s{3}}%
 \@x{\@s{16.4} {\p@assert} buffer [ rptr [ i ] ] \.{=} rptr [ i ] \.{+} 1000
 {\p@semicolon}}%
\@x{ r\_read\_buf\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{16.4} buffer [ rptr [ i ] ] \.{:=} 0 {\p@semicolon}}%
\@x{ r\_unlock\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{16.4} status [ rptr [ i ] ] \.{:=} UNUSED {\p@semicolon}}%
\@x{ r\_done\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{16.4} {\p@return} {\p@semicolon}}%
\@x{ {\p@end} {\p@procedure} {\p@semicolon}}%
\end{tlatex}
\newline

The reader performs a non-zero check on outstanding. If outstanding is zero,
queue is empty and reader early returns.\newline 

If outstanding is K, then at most K readers can reserve a index to read. If system 
has M readers, then M-K readers will fail to reserve a read index. The readers now 
compete to reserve a read. More specifically: 
\begin{itemize}
    \item Reader loads outstanding, stores that onto local variable A
    \item Reader early returns if A is zero 
    \item Reader calls rv = CAS(A, A-1)
    \item If rv is non-success, go back to the top
\end{itemize}

If rv is non-success, another reader has \textit{won} the reservation. The
current reader can attempt to reserve again if \textit{outstanding} is
non-zero.\newline

If rv is success, the reader is \textit{gauranteed} a read. However, readers may
need to compete to reserve an available index. This is done by attempting to CAS
update the index status from WRITTEN to READING. Failing the CAS indicate
another reader has reserved this index, and the reader will bump the read
pointer and try to reserve the next index.\newline

Now let us take a look at the writer implementation:\newline

\begin{pcal}
procedure writer() begin
w_chk_full:         
    if outstanding = N - 1 then 
    w_early_ret:            
        return; 
    end if;
w_chk_st:           
    if status[wptr] # UNUSED then 
    w_early_ret2:           
        return;
    end if;
w_write_buf:        
    buffer[wptr] := wptr + 1000;
w_mark_written:     
    status[wptr] := WRITTEN;
w_inc_wptr:         
    wptr := (wptr + 1) % N;
w_inc:              
    outstanding := outstanding + 1;
w_done:             
    return;
end procedure; 
\end{pcal}
\begin{tlatex}
\@x{ {\p@procedure} writer {\p@lparen} {\p@rparen} {\p@begin}}%
\@x{ w\_chk\_full\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{16.4} {\p@if} outstanding \.{=} N \.{-} 1 {\p@then}}%
\@x{\@s{16.4} w\_early\_ret\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{32.8} {\p@return} {\p@semicolon}}%
\@x{\@s{16.4} {\p@end} {\p@if} {\p@semicolon}}%
\@x{ w\_chk\_st\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{16.4} {\p@if} status [ wptr ] \.{\neq} UNUSED {\p@then}}%
\@x{\@s{16.4} w\_early\_ret2\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{32.8} {\p@return} {\p@semicolon}}%
\@x{\@s{16.4} {\p@end} {\p@if} {\p@semicolon}}%
\@x{ w\_write\_buf\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{16.4} buffer [ wptr ] \.{:=} wptr \.{+} 1000 {\p@semicolon}}%
\@x{ w\_mark\_written\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{16.4} status [ wptr ] \.{:=} WRITTEN {\p@semicolon}}%
\@x{ w\_inc\_wptr\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{16.4} wptr \.{:=} ( wptr \.{+} 1 ) \.{\%} N {\p@semicolon}}%
\@x{ w\_inc\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{16.4} outstanding \.{:=} outstanding \.{+} 1 {\p@semicolon}}%
\@x{ w\_done\@s{.5}\textrm{:}\@s{3}}%
\@x{\@s{16.4} {\p@return} {\p@semicolon}}%
\@x{ {\p@end} {\p@procedure} {\p@semicolon}}%
\end{tlatex}
\newline

The writer first checks outstanding, and early return if queue is full. After
fullness check, the writer then checks if the current index is UNUSED.  This is
to account for the edge case where a reader has performed the reservation first
step to decrement outstanding but haven't done the actual read. If both checks
pass, then writer now has an UNUSED index it can write to.

\section{Safety}

The SPMC algorithm can get into all sorts of weird states. For example:
\begin{itemize}
    \item Readers lapsing each other
    \item A reader attempts to lapse writer 
    \item A reader starves the other readers
    \item A reader lapse all other readers
    \item A slow reader blocks the system
\end{itemize}

In a many reader system, we need to ensure when the readers have reserved an index to read, 
they have exclusvie access to the index. This can be represented as below:\newline

\begin{tla}
ExclusiveReservation == 
    \A x, y \in READERS: 
        (x /= y /\ pc[x] = "r_read_buf" /\ pc[y] = "r_read_buf") => (rptr[x] # rptr[y])
\end{tla}
\begin{tlatex}
\@x{ ExclusiveReservation \.{\defeq}}%
\@x{\@s{16.4} \A\, x ,\, y \.{\in} READERS \.{:}}%
 \@x{\@s{16.4} ( x \.{\neq} y \.{\land} pc [ x ] \.{=}\@w{r\_read\_buf}
 \.{\land} pc [ y ] \.{=}\@w{r\_read\_buf} ) \.{\implies} ( rptr [ x ]
 \.{\neq} rptr [ y ] )}%
\end{tlatex}
\newline

Similarly, reader and writer cannot overlap on the same index:\newline
\begin{tla}
ExclusiveReadWrite == 
    \A x \in READERS: 
        (pc[x] = "r_read_buf" /\ pc[WRITER] = "w_write_buf") => (rptr[x] # wptr)
\end{tla}
\begin{tlatex}
\@x{ ExclusiveReadWrite \.{\defeq}}%
\@x{\@s{16.4} \A\, x \.{\in} READERS \.{:}}%
 \@x{\@s{20.5} ( pc [ x ] \.{=}\@w{r\_read\_buf} \.{\land} pc [ WRITER ]
 \.{=}\@w{w\_write\_buf} ) \.{\implies} ( rptr [ x ] \.{\neq} wptr )}%
\end{tlatex}

\section{Liveness}

In all of the above case, the system \textit{correctness} need to be maintained.

The liveness property defines the correctness of the algorithm.

\begin{tla}
Liveness ==
    /\ \A k \in 0..N-1:
        buffer[k] = 0 ~> buffer[k] # 0
    /\ \A k \in 0..N-1:
        buffer[k] # 0 ~> buffer[k] = 0
\end{tla}

\begin{tla}
Liveness2 == 
    /\ (status[0] = WRITTEN /\ status[1] = UNUSED /\ status[2] = WRITTEN) ~> (status[0] = UNUSED)
    /\ (status[0] = WRITTEN /\ status[1] = UNUSED /\ status[2] = WRITTEN) ~> (status[2] = UNUSED)
\end{tla}

% \end{document}
