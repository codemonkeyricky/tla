% \documentclass[draft]{report}

\RequirePackage{luatex85}% TeXLive 2017 fix for \geometry
\documentclass{kdp}
\usepackage{geometry}

% \usepackage{algorithm}% http://ctan.org/pkg/algorithms
\usepackage{algpseudocode}% http://ctan.org/pkg/algorithmicx
% \usepackage{algorithm}% http://ctan.org/pkg/algorithms
% \usepackage{algpseudocode}
\usepackage{tlatex}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{comment}
\usepackage{fancyhdr}
\usepackage{amssymb}
\usepackage{inputenc}
\usepackage{svg}
\usepackage{framed}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{automata, positioning, arrows}

% \usepackage{hyperref}
% \hypersetup{
%     colorlinks,
%     citecolor=black,
%     filecolor=black,
%     linkcolor=black,
%     urlcolor=black
% }

% !TeX spellcheck = en_GB 

% Configure fancyhdr
\pagestyle{fancy}
\fancyhf{} % Clear default header and footer

% Header settings
\fancyhead[L]{\nouppercase{\leftmark}} % Chapter number and title on the left
% \fancyhead[C]{Center Header}    % Centered header
\fancyhead[R]{\thepage}     % Right-aligned header

% Footer settings
% \fancyfoot[L]{Left Footer}      % Left-aligned footer
% \fancyfoot[C]{Page \thepage}    % Centered footer with page number
% \fancyfoot[R]{Right Footer}     % Right-aligned footer

% java -cp /home/richard/dev/tla2tex/tla2tools.jar  tla2tex.TeX  book.tex 

\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\title{Scalable Software with Elixir \\ Early Preview}

% \maketitle

\author{Richard Tang}
\date{\today}
\begin{document}
\maketitle

% \vspace{1cm} % Adjust spacing as needed
% \begin{center}
% \textbf{First Draft}
% \end{center}

\section*{Acknowledgement}

\tableofcontents

\chapter{Scalable Software}

\part{Trees}

In this part we will focus on the language semantics 

\chapter{Functional Language}

\chapter{Data Structure}

\chapter{Pipe}

\part{Forest}

The superpower of Elixir is not the niceities of the language, but the ecosystem
around it. The Erlang process model forces software architects to design the
with the actor model. If a software design is already actor model compliant, it 
is also by definition scalable. 

\chapter{Design Pattern}

Elixir forces certain design pattern

\chapter{Pushing the Limit}

\chapter{Observability}

\chapter{BEAM} 

\chapter{Cluster} 

\chapter{Byte Code} 

\chapter{Reference}

Concurrent Data Processing in Elixir

GigCityElixir23 - Bryan Hunter
https://www.youtube.com/watch?v=pQ0CvjAJXz4

\end{document}
