% \begin{document}


\chapter{Simple Gossip Protocol}

In a distributed system, a cluster of nodes collectively provide a serivce. A
distributed system may have 10s to 100s of nodes working together to offer the
service in a geo diverse environment to maximize uptime. The nodes often
have requirements to know about each other. In the context of distributed
database, a node may need to know the key range another of its peers. The
cluster needs a way to communicate this information. One such mechanism is the
gossip protocol.\newline

Gossip protocol allows nodes to fetch the latest cluster information in a
distributed fashion. Prior to gossip protocol, nodes in a cluster learn about
its neighbours by contacting a centralized server. This introduces a single
failure point in the system. Gossip protocol relies on nodes to initiate 
the data exchange, and the nodes in the cluster periodically selects a set of neighbors to
gossip with. \newline

Assume a N node cluster, at some periodic interval a node selects k neighbours
to gossip with. The total amount of gossip propagation time is described
logrithmticly below:

\begin{equation} 
    propagation\_time = \log_k N * gossip\_interval
\end{equation}

With the total number of messages exchanged: 
\begin{equation} 
    messages\_exchanged = \log_k N * k
\end{equation}

\section{Design}

In this chapter we will implement a simplified gossip model where: 
\begin{itemize}
    \item Each node has a version.
    \item Each node caches the version of all other nodes.
    \item A pair of nodes are randomly selected to gossip 
    \item A node can restart. Restarting a node clears the node's version cache
    of the other nodes.
    \item A node can bump its own version.
\end{itemize}

If the gossip protocol works correctly, every node should eventually have the
latest version of all the nodes.

\section{Spec}

In gossip protocol, every node needs to remember all its peers current
version:\newline

\begin{tla}
Init ==
    /\ version = [i \in Servers |-> [j \in Servers |-> 0]]
Next ==
    \/ \E i \in Servers:
        /\ Bump(i)
    \/ \E i, j \in Servers:
        /\ ExchangeGossip(i, j)
    \/ \E i \in Servers:
        /\ Restart(i)
\end{tla}
\begin{tlatex}
\@x{ Init \.{\defeq}}%
 \@x{\@s{16.4} \.{\land} version \.{=} [ i \.{\in} Servers \.{\mapsto} [ j
 \.{\in} Servers \.{\mapsto} 0 ] ]}%
\@x{ Next \.{\defeq}}%
\@x{\@s{16.4} \.{\lor} \E\, i \.{\in} Servers \.{:}}%
\@x{\@s{20.5} \.{\land} Bump ( i )}%
\@x{\@s{16.4} \.{\lor} \E\, i ,\, j \.{\in} Servers \.{:}}%
\@x{\@s{20.5} \.{\land} ExchangeGossip ( i ,\, j )}%
\@x{\@s{16.4} \.{\lor} \E\, i \.{\in} Servers \.{:}}%
\@x{\@s{20.5} \.{\land} Restart ( i )}%
\end{tlatex}
\newline

The \textit{Init} formula simply declares version to be a two dimension array
with all elements initialized to 0. \textit{Next} allows either bumping version
of a server, pick a pair of nodes to gossip, or restart a server.\newline

The following provides definition to these steps:\newline

\begin{tla}
ExchangeGossip(i, j) == 
    LET 
        Max(a, b) == IF a > b THEN a ELSE b
        updated == [k \in Servers |-> Max(version[i][k], version[j][k])]
        version_a == [version EXCEPT ![i] = updated]
        version_ab == [version_a EXCEPT ![j] = updated]
    IN 
        /\ version' = version_ab 
\end{tla}
\begin{tlatex}
\@x{ ExchangeGossip ( i ,\, j ) \.{\defeq}}%
\@x{\@s{16.4} \.{\LET}}%
 \@x{\@s{32.8} Max ( a ,\, b ) \.{\defeq} {\IF} a \.{>} b \.{\THEN} a
 \.{\ELSE} b}%
 \@x{\@s{32.8} updated \.{\defeq} [ k \.{\in} Servers \.{\mapsto} Max (
 version [ i ] [ k ] ,\, version [ j ] [ k ] ) ]}%
 \@x{\@s{32.8} version\_a \.{\defeq} [ version {\EXCEPT} {\bang} [ i ] \.{=}
 updated ]}%
 \@x{\@s{32.8} version\_ab \.{\defeq} [ version\_a {\EXCEPT} {\bang} [ j ]
 \.{=} updated ]}%
\@x{\@s{16.4} \.{\IN}}%
\@x{\@s{32.8} \.{\land} version \.{'} \.{=} version\_ab}%
\end{tlatex}
\newline

When two server gossip, they gossip about all the nodes (including themselves)
and update both of their version cache with the more up-to-date entry between
the two. The \textit{LET..IN} syntax enables local macro definition. In this
example, we use temporary variables defined inside \textit{LET}, and update the
primed variable inside the \textit{IN} clause.\newline

\begin{tla}
Bump(i) == 
    /\ version[i][i] # MaxVersion 
    /\ version' = [version EXCEPT ![i] = [k \in Servers |-> 
        IF i # k THEN version[i][k] ELSE version[i][k] + 1]]
\end{tla}
\begin{tlatex}
\@x{ Bump ( i ) \.{\defeq}}%
\@x{ \.{\land} version [ i ] [ i ] \.{\neq} MaxVersion}%
 \@x{ \.{\land} version \.{'} \.{=} [ version {\EXCEPT} {\bang} [ i ] \.{=} [
 k \.{\in} Servers \.{\mapsto}}%
 \@x{\@s{4.1} {\IF} i \.{\neq} k \.{\THEN} version [ i ] [ k ] \.{\ELSE}
 version [ i ] [ k ] \.{+} 1 ] ]}%
\end{tlatex}
\newline

The first conjunction bounds the search space until a node is at
\textit{MaxVersion}. The second conjunction describes what \textit{version'}
should be: \textit{version'} is the same as \textit{version}, except for
\textit{version[i]}. The updated \textit{version[i]} is the same as
\textit{version[i]}, except \textit{version[i][i]} is bumped. \newline

\begin{tla}
Restart(i) == 
    /\ version' = [version EXCEPT ![i] = [k \in Servers |-> 
        IF i # k THEN 0 ELSE version[i][i]]]
\end{tla}
\begin{tlatex}
\@x{ Restart ( i ) \.{\defeq}}%
 \@x{\@s{16.4} \.{\land} version \.{'} \.{=} [ version {\EXCEPT} {\bang} [ i ]
 \.{=} [ k \.{\in} Servers \.{\mapsto}}%
 \@x{\@s{20.5} {\IF} i \.{\neq} k \.{\THEN} 0 \.{\ELSE} version [ i ] [ i ] ]
 ]}%
\end{tlatex}
\newline

Upon \textit{Restart}, a server reloads from its local storage (so it's own
version persist), but the server needs to re-learn the cluster status (all other
entries in its version cache is wiped). 

\section{Safety}

\section{Liveness}

The intent of gossip protocol is to ensure the cluster remains up-to-date in the
presence of failure (represented by \textit{Restart}). The following describes 
the expected system behaviour:
\begin{itemize}
    \item Since the state graph is bound by MaxVersion, one or more Server
    should eventually make it to MaxVersion
    \item However, verifying one Server makes it to 
\end{itemize}

\begin{tla}
Liveness == 
    \E i, j \in Servers: 
        /\ i # j
        /\ []<>(version[i][i] = MaxVersion /\ version[i][i] = MaxVersion /\ version[i][j] = MaxVersion)
\end{tla}
\begin{tlatex}
\@x{ Liveness \.{\defeq}}%
\@x{\@s{16.4} \E\, i ,\, j \.{\in} Servers \.{:}}%
\@x{\@s{16.4} \.{\land} i \.{\neq} j}%
 \@x{\@s{16.4} \.{\land} {\Box} {\Diamond} ( version [ i ] [ i ] \.{=}
 MaxVersion \.{\land} version [ i ] [ i ] \.{=} MaxVersion \.{\land} version
 [ i ] [ j ] \.{=} MaxVersion )}%
\end{tlatex}

% \end{document}
