% \begin{document}


\chapter{Simple Gossip Protocol}

In a distributed system, a cluster of nodes collectively provide a serivce. A
distributed system may have 10s to 100s of nodes working together to offer the
service in a geo diverse environment to maximize uptime. The nodes often
have requirements to know about each other. In the context of distributed
database, a node may need to know the key range another of its peers. The
cluster needs a way to communicate this information. One such mechanism is the
gossip protocol.\newline

Gossip protocol allows nodes to fetch the latest cluster information in a
distributed fashion. Prior to gossip protocol, nodes in a cluster learn about
its neighbours by contacting a centralized server. This introduces a single
failure point in the system. Gossip protocol relies on nodes to initiate 
the data exchange, and the nodes in the cluster periodically selects a set of neighbors to
gossip with. \newline

Assume a N node cluster, at some periodic interval a node selects k neighbours
to gossip with. The total amount of gossip propagation time is described
logrithmticly below:

\begin{equation} 
    propagation\_time = \log_k N * gossip\_interval
\end{equation}

With the total number of messages exchanged: 
\begin{equation} 
    messages\_exchanged = \log_k N * k
\end{equation}

\section{Design}

In this chapter we will implement a simplified gossip model where: 
\begin{itemize}
    \item Each node has a version.
    \item Each node caches the version of all other nodes.
    \item A pair of nodes are randomly selected to gossip 
    \item A node can restart. Restarting a node clears the node's version cache
    of the other nodes.
    \item A node can bump its own version.
\end{itemize}

If the gossip protocol works correctly, every node should eventually have the
latest version of all the nodes.

\section{Spec}

In gossip protocol, every node needs to remember all its peers current
version:\newline

\begin{tla}
Init ==
    /\ version = [i \in Servers |-> [j \in Servers |-> 0]]
Next ==
    \/ \E i \in Servers:
        /\ Bump(i)
    \/ \E i, j \in Servers:
        /\ Gossip(i, j)
    \/ \E i \in Servers:
        /\ Restart(i)
\end{tla}
\begin{tlatex}
\@x{ Init \.{\defeq}}%
 \@x{\@s{16.4} \.{\land} version \.{=} [ i \.{\in} Servers \.{\mapsto} [ j
 \.{\in} Servers \.{\mapsto} 0 ] ]}%
\@x{ Next \.{\defeq}}%
\@x{\@s{16.4} \.{\lor} \E\, i \.{\in} Servers \.{:}}%
\@x{\@s{20.5} \.{\land} Bump ( i )}%
\@x{\@s{16.4} \.{\lor} \E\, i ,\, j \.{\in} Servers \.{:}}%
\@x{\@s{20.5} \.{\land} Gossip ( i ,\, j )}%
\@x{\@s{16.4} \.{\lor} \E\, i \.{\in} Servers \.{:}}%
\@x{\@s{20.5} \.{\land} Restart ( i )}%
\end{tlatex}
\newline

The \textit{Init} formula simply declares version to be a two dimension array
with all elements initialized to 0. \textit{Next} allows either bumping version
of a server, pick a pair of nodes to gossip, or restart a server.\newline

The following provides definition to these steps:\newline

\begin{tla}
Gossip(i, j) == 
    LET 
        Max(a, b) == IF a > b THEN a ELSE b
        updated == [k \in Servers |-> Max(version[i][k], version[j][k])]
        version_a == [version EXCEPT ![i] = updated]
        version_ab == [version_a EXCEPT ![j] = updated]
    IN 
        /\ version' = version_ab 
\end{tla}
\begin{tlatex}
\@x{ Gossip ( i ,\, j ) \.{\defeq}}%
\@x{\@s{16.4} \.{\LET}}%
 \@x{\@s{32.8} Max ( a ,\, b ) \.{\defeq} {\IF} a \.{>} b \.{\THEN} a
 \.{\ELSE} b}%
 \@x{\@s{32.8} updated \.{\defeq} [ k \.{\in} Servers \.{\mapsto} Max (
 version [ i ] [ k ] ,\, version [ j ] [ k ] ) ]}%
 \@x{\@s{32.8} version\_a \.{\defeq} [ version {\EXCEPT} {\bang} [ i ] \.{=}
 updated ]}%
 \@x{\@s{32.8} version\_ab \.{\defeq} [ version\_a {\EXCEPT} {\bang} [ j ]
 \.{=} updated ]}%
\@x{\@s{16.4} \.{\IN}}%
\@x{\@s{32.8} \.{\land} version \.{'} \.{=} version\_ab}%
\end{tlatex}
\newline

When two server gossip, they gossip about all the nodes (including themselves)
and update both of their version cache with the more up-to-date entry between
the two. The \textit{LET..IN} syntax enables local macro definition. In this
example, we use temporary variables defined inside \textit{LET}, and update the
primed variable inside the \textit{IN} clause.\newline

\begin{tla}
Bump(i) == 
    /\ version[i][i] # MaxVersion 
    /\ version' = [version EXCEPT ![i] = [k \in Servers |-> 
        IF i # k THEN version[i][k] ELSE version[i][k] + 1]]
\end{tla}
\begin{tlatex}
\@x{ Bump ( i ) \.{\defeq}}%
\@x{ \.{\land} version [ i ] [ i ] \.{\neq} MaxVersion}%
 \@x{ \.{\land} version \.{'} \.{=} [ version {\EXCEPT} {\bang} [ i ] \.{=} [
 k \.{\in} Servers \.{\mapsto}}%
 \@x{\@s{4.1} {\IF} i \.{\neq} k \.{\THEN} version [ i ] [ k ] \.{\ELSE}
 version [ i ] [ k ] \.{+} 1 ] ]}%
\end{tlatex}
\newline

The action only permits version bump if the Server hasn't made it to 
\textit{MaxVersion}. When the Server bumps the version, it only bumps its own 
version and keeps all other version in its version cache as is. \newline

\begin{tla}
Restart(i) == 
    /\ version' = [version EXCEPT ![i] = [k \in Servers |-> 
        IF i # k THEN 0 ELSE version[i][i]]]
\end{tla}
\begin{tlatex}
\@x{ Restart ( i ) \.{\defeq}}%
 \@x{\@s{16.4} \.{\land} version \.{'} \.{=} [ version {\EXCEPT} {\bang} [ i ]
 \.{=} [ k \.{\in} Servers \.{\mapsto}}%
 \@x{\@s{20.5} {\IF} i \.{\neq} k \.{\THEN} 0 \.{\ELSE} version [ i ] [ i ] ]
 ]}%
\end{tlatex}
\newline

Upon \textit{Restart}, a server reloads from its local storage (so it's own
version persist), but the server needs to re-learn the cluster status (all other
entries in its version cache is wiped).\newline

The \textit{Spec} defines three actions: \textit{Bump}, \textit{Restart},
\textit{Gossip}. Without any fairness description, \textit{Any} permutation of
these actions are allowed by the Spec, and \textit{will} be checked by the model
checker:
\begin{itemize}
    \item Restart, Restart, Restart,...
    \item Bump, Bump, Bump, Bump ...
    \item Restart, Gossip, Restart, Gossip, ... 
\end{itemize}

We will discuss how to specify fairness in the Liveness section of this chapter.

\section{Safety}

\section{Liveness}

The expected behaviour of a system using gossip protocol is to ensure the
cluster converges towards higher version number for all servers even in the
presence of failure (represented by \textit{Restart}). This means we need to
gaurantee \textit{Bump} is always being called. Without this gaurantee, the Spec
can trap in a \textit{Restart} and \textit{Gossip} loop. To ensure \textit{Bump}
is always called, we need to add fairness description:\newline 

\begin{tla}
Spec ==
  /\ Init
  /\ [][Next]_vars
  /\ WF_vars(Next)
  /\ \A i \in Servers: 
    WF_vars(Bump(i))
\end{tla}
\begin{tlatex}
\@x{ Spec \.{\defeq}}%
\@x{\@s{8.2} \.{\land} Init}%
\@x{\@s{8.2} \.{\land} {\Box} [ Next ]_{ vars}}%
\@x{\@s{8.2} \.{\land} {\WF}_{ vars} ( Next )}%
\@x{\@s{8.2} \.{\land} \A\, i \.{\in} Servers \.{:}}%
\@x{\@s{16.4} {\WF}_{ vars} ( Bump ( i ) )}%
\end{tlatex}

The the model checker explores all possible transitions permitted by the Spec.
This includes calling Restart repeatedly, calling Gossip repeatedly, calling any
subset of the actions repeatedly. The fairness description gaurantees that if
the enabling condition of an action is true, the action will take. If the system
is trapped in a Restart and Gossip loop when Bump can be called, specifying fairness 
for Bump ensures Bump is called, breaking the loop.\newline

With the Spec ensuring the system always mgirate torwards higher version number, 
we can now define the Liveness property:\newline

\begin{tla}
Liveness == 
    \E i, j \in Servers: 
        /\ i # j
        /\ []<>(version[i][i] = MaxVersion /\ version[i][i] = MaxVersion /\ version[i][j] = MaxVersion)
\end{tla}
\begin{tlatex}
\@x{ Liveness \.{\defeq}}%
\@x{\@s{16.4} \E\, i ,\, j \.{\in} Servers \.{:}}%
\@x{\@s{16.4} \.{\land} i \.{\neq} j}%
 \@x{\@s{16.4} \.{\land} {\Box} {\Diamond} ( version [ i ] [ i ] \.{=}
 MaxVersion \.{\land} version [ i ] [ i ] \.{=} MaxVersion \.{\land} version
 [ i ] [ j ] \.{=} MaxVersion )}%
\end{tlatex}

Since the system is 

% \end{document}
