\chapter{Selective Retransmit}

Assume client device that playsback a video stream. Structurelly, a video is
composed of frames, frames are then segmented into packets to stream across a 
network. The client device recombines the packets into a frame, then sequence
the frame to playback the video.\newline

However, network is not-deterministic. Depending on the route the packets take
to get to the client, they may arrive out-of-order. The client may need to
maintain a receive buffer for the packets, re-order the packets back into
sequence before pushing the packets down to decoding engine.\newline

The network may also drop packets if any of the switches gets too busy. In the
case of a packet drop, the client has a few options. The client can either
discard the frame and let the decoding engine downstream to deal with it (which
may ressult in  visible artifacts during play back). The client can request the
whole frame to be re-sent, which results in additional bandwidith consumption.
The client can selectively request the missing packet to be retransmited, which
will minimize additional bandwidth consumption, but increases implementation 
complexity.\newline 

In this chapter, we will implement a simple selective retransmit
algorithm.\newline

\begin{center}

\begin{tikzpicture}[
    packet/.style={rectangle, draw, fill=blue!20, minimum width=1cm, minimum height=0.8cm},
    missing/.style={rectangle, draw, dashed, fill=red!20, minimum width=1cm, minimum height=0.8cm},
    arrow/.style={->, >=stealth, thick}
]

    % Draw packets
    \node[packet] (p0) at (0,0) {\(pkt\ 0\)};
    \node[packet, right=0.5cm of p0] (p2) {\(pkt\ 1\)};
    \node[missing, right=0.5cm of p2] (missing1) {\(lost\)};
    \node[packet, right=0.5cm of missing1] (p4) {\(pkt\ 3\)};
    \node[packet, right=0.5cm of p4] (p5) {\(pkt\ 4\)};
    \node[right=0.5cm of p5] (dots) {\(\dots\)}; % Just dots, no box
    \node[packet, right=0.5cm of dots] (pn) {\(pkt\_n\)};

    % Draw arrows between packets
    \draw[arrow] (p0.east) -- (p2.west);
    \draw[arrow] (p2.east) -- (missing1.west);
    \draw[arrow] (missing1.east) -- (p4.west);
    \draw[arrow] (p4.east) -- (p5.west);
    \draw[arrow] (p5.east) -- (dots);
    \draw[arrow] (dots) -- (pn.west);

    % Add arrow pointing to "lost" with caption
    \draw[arrow, red] ([yshift=0.3cm] missing1.north) -- (missing1.north) 
        node[midway, above, text=red] {request to retransmit};

\end{tikzpicture}

\end{center}

Since packets may arrive out-of-order, the server stamps the packets with
sequence number to allow the client to order the packets as they arrive.
Once the client has a set of ordered packets, it moves the packets from the 
receive buffer into the decoding engine to be displayed.\newline

The video packets are often sent via unreliable channel to minimize network
overhead and latency. The client sends acknowledgement back to the server to
acknowledge the received packet. This indicates to the server it can send more
video data to the client. Acknowlegements are not latency sensitive in
nature, and take up a very small proportion of bandwidth, so they are
transported through reliable channel.\newline

The following illustrates packet reorder handling:
\begin{center}
\begin{tikzpicture}[
    lifeline/.style={thick},
    message/.style={->, >=stealth, dashed},
    activation/.style={rectangle, fill=blue!20, minimum width=0.5cm, minimum height=0.8cm} ]

    \node[] (client) at (0,0) {Client};
    \node[] (server) at (4,0) {Server};

    \draw[lifeline] (client.south) -- ++(0,-8);
    \draw[lifeline] (server.south) -- ++(0,-8);

    \draw[message] ([yshift=-1cm] client.south) -- node[above] {pkt \#0} ([yshift=-2cm] server.south);
    \draw[message] ([yshift=-2cm] client.south) -- node[above] {pkt \#2} ([yshift=-3cm] server.south);
    \draw[message] ([yshift=-3cm] client.south) -- node[above] {pkt \#1} ([yshift=-4cm] server.south);
    \draw[message] ([yshift=-6cm] server.south) -- node[above] {ack \#3} ([yshift=-7cm] client.south);

    \node[activation] at ([yshift=-5cm] server.south) {Process pkt \#0..2};
\end{tikzpicture}
\end{center}

The following illustrates packet loss handling:
\begin{center}
\begin{tikzpicture}[
    lifeline/.style={thick},
    message/.style={->, >=stealth, dashed},
    activation/.style={rectangle, fill=blue!20, minimum width=0.5cm, minimum height=0.8cm} ]

    \node[] (client) at (0,0) {Client};
    \node[] (server) at (4,0) {Server};

    \draw[lifeline] (client.south) -- ++(0,-11);
    \draw[lifeline] (server.south) -- ++(0,-11);

    \draw[message] ([yshift=-1cm] client.south) -- node[above] {pkt \#0} ([yshift=-2cm] server.south);
    \draw[message] ([yshift=-2cm] client.south) -- node[above] {pkt \#2} ([yshift=-3cm] server.south);
    \draw[message] ([yshift=-4cm] server.south) -- node[above] {req \#1} ([yshift=-5cm] client.south);
    \draw[message] ([yshift=-6cm] client.south) -- node[above] {pkt \#1} ([yshift=-7cm] server.south);
    \draw[message] ([yshift=-9cm] server.south) -- node[above] {ack \#3} ([yshift=-10cm] client.south);

    \node[activation] at ([yshift=-8cm] server.south) {Process pkt \#0..2};
 
\end{tikzpicture}
\end{center}

There are other design considerations. The server is allowed to send up to W
packets before getting an acknowledgement, this reduces latency perceived by the
user. The client also doesn't need to acknowledge all the packets, since the
server assumes once an acknowledgement of packet N is received, then all packets
prior to N have also been received.

\section{Requirement}

With the above description, we are now ready to provide a more formal
description for our requirement:

\begin{itemize}
    \item Client is the receiver that displays the video stream 
    \item Server is the sender that sends the video stream 
    \item Server always sends the packets in-order
    \item Client may receive the packets out-of-order 
    \item Client may never receive some packet due to loss
    \item Server can send up to W packets before an acknowledgement is received
    \item Per packet sequence number is represented by fixed number of bytes in
    the network header, the sequence number will eventually wrap around once it
    hits the maximum representable value. This upper limit will be represented
    by the constant N 
    \item Client will remove the packets from the receive buffer once the
    sequence number of the received packets are contiguous. The client will also
    send an acknowledgement back to the Server with the most recent sequence
    number
\end{itemize}

\section{Spec}
