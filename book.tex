
\documentclass{report}

\usepackage{tlatex}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{comment}
\usepackage{fancyhdr}
\usepackage{amssymb}
\usepackage{inputenc}
\usepackage{svg}

\usepackage{tikz}
\usetikzlibrary{automata, positioning, arrows}


% !TeX spellcheck = en_GB 

% Configure fancyhdr
\pagestyle{fancy}
\fancyhf{} % Clear default header and footer

% Header settings
\fancyhead[L]{\nouppercase{\leftmark}} % Chapter number and title on the left
% \fancyhead[C]{Center Header}    % Centered header
\fancyhead[R]{\thepage}     % Right-aligned header

% Footer settings
% \fancyfoot[L]{Left Footer}      % Left-aligned footer
% \fancyfoot[C]{Page \thepage}    % Centered footer with page number
% \fancyfoot[R]{Right Footer}     % Right-aligned footer

% java -cp /home/richard/dev/tla2tex/tla2tools.jar  tla2tex.TeX  book.tex 

\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\title{Learning TLA+ by Examples}
\author{Richard Tang}
\date{\today}
\begin{document}
\maketitle
\tableofcontents

\include{intro}

\chapter{TLA+ Primer}

\section{Design Intent}

The key insight into TLA+ is modelling a system as a state machine. A simple
digital clock can be represented by two variables, hour and minute and the
number of possible states in a digital clock is $24 * 60 = 1440$.  For example,
10:01 is the next state 10:00 can transition to. Extrapolating further, Asssume
an arbitrarily system described by N variables, each variable having K possible
values such arbitrary system can have up to $N^K$ state.\newline

For every specification, designer can specify \textit{safety} proerty (or
invariants) that must be true in \textit{every} states. For example, in any
state of the digital clock hour \textit{must} be between 0 to 23, or formally
described as $hour \in 0..23$. Similarly, minute must have value between 0 to
59, or $minute \in 0..59$. Examples invariants of a system include: Only one
thread has exclusive access to a critical region, all variables in the system
are within allowable value, resource allocation manager never allocates more
than available resources.\newline

Designer can also specify \textit{liveness} property. These are properties to be
satisfied by a \textit{sequence of state}. One liveness property for the digital
clock could be when the clock is $10:00$, it will eventually become $11:00$
(\textit{$10:00$ leads to $11:00$}). Example liveness property include: a
distributed system eventually converges, the scheduler eventually schedules
every tasks in the task queue, the resource allocation manager fairly allocates
resources. \newline

A TLA+ Spec can be checked by TLC, the model checker. TLC uses
\textit{breath-first search} algorithm to explore \textit{all} states in the
state machine and ensure safety and liveness properties are upheld.\newline

A TLA+ Spec describes the system using \textit{temporal logic}. The syntax may 
appear unfamiliar if one hasn't seen it before, but like any other programming 
language an initiated reader should become familiarized quickly. In this book I
will use 

\section{Requirement}

In this example, we will specify a \textit{digital clock}. The digital clock has
a few simple requirements:
\begin{itemize}
    \item Two variables to represent state: hour and minute
    \item The clock increment one minute at a time
    \item The clock wraps around at midnight (ie. 23:59 transitions to 00:00)
\end{itemize}

\section{Spec}

The \textit{Init} state of such system can be described as: \newline
\begin{tla}
    Init ==
        /\ hour = 0
        /\ minute = 0
\end{tla}
\begin{tlatex}
\@x{\@s{16.4} Init \.{\defeq}}%
\@x{\@s{32.8} \.{\land} hour \.{=} 0}%
\@x{\@s{32.8} \.{\land} minute \.{=} 0}%
\end{tlatex}
 \newline

$\defeq$ is the \textit{defines equal} symbol and $\land$ is the \textit{logical
and} symbol. The above TLA+ syntax can be read as \textit{Init} state is defined
as both hour and minute are both 0.\newline

The spec also always include a $Next$ definition, an \textit{action formula}
describing how the system transition from one state to another. Action formula
contains \textit{primed} variables what happens to the variable in its next
state. The $Next$ action for the digital clock can be defined as:\newline

\begin{tla}
    NextHour ==
        /\ minute = 59 
        /\ hour' = (hour + 1) % 24
        /\ minute' = 0
    NextMinute == 
        /\ minute # 59
        /\ hour' = hour 
        /\ minute' = minute + 1 
    Next ==
        \/ NextMinute
        \/ NextHour
\end{tla}
\begin{tlatex}
\@x{\@s{16.4} NextHour \.{\defeq}}%
\@x{\@s{32.8} \.{\land} minute \.{=} 59}%
\@x{\@s{32.8} \.{\land} hour \.{'} \.{=} ( hour \.{+} 1 ) \.{\%} 24}%
\@x{\@s{32.8} \.{\land} minute \.{'} \.{=} 0}%
\@x{\@s{16.4} NextMinute \.{\defeq}}%
\@x{\@s{32.8} \.{\land} minute \.{\neq} 59}%
\@x{\@s{32.8} \.{\land} hour \.{'} \.{=} hour}%
\@x{\@s{32.8} \.{\land} minute \.{'} \.{=} minute \.{+} 1}%
\@x{\@s{16.4} Next \.{\defeq}}%
\@x{\@s{32.8} \.{\lor} NextMinute}%
\@x{\@s{32.8} \.{\lor} NextHour}%
\end{tlatex}
 \newline

Here's a breakdown of what the spec does:
\begin{itemize}
    \item $Next$ can take $NextMinute$ or $NextHour$
    \item $Next$ takes $NextMinute$ when $minute$ is not 59, next hour is hour, next minute is minute + 1. 
    \item $Next$ takes $NextHour$ when $minute$ is 59, next hour is (hour + 1) modulus 24, next minute set to 0
\end{itemize}

Technically it's possible for $Next$ to take both $NextMinute$ and $NextHour$.
This is not possible in this definition as $NextHour$ and $NextMinute$ are
defined in a \textit{mutually exlusively} fashion.\newline

Finally, the spec itself is formally defined as:\newline
\begin{tla}
    vars == <<hour, minute>>
    Spec ==
        /\ Init
        /\ [][Next]_vars
\end{tla}
\begin{tlatex}
\@x{\@s{16.4} vars\@s{0.63} \.{\defeq} {\langle} hour ,\, minute {\rangle}}%
\@x{\@s{16.4} Spec \.{\defeq}}%
\@x{\@s{32.8} \.{\land} Init}%
\@x{\@s{32.8} \.{\land} {\Box} [ Next ]_{ vars}}%
\end{tlatex}
\newline

$\Box[Next]_{vars}$ deserves some special attention:
\begin{itemize}
    \item $vars$ is defined to be \textit{all} variables in the spec. Different
    combination of these variables constitute the states of the system (eg.
    23:59 and 00:00 are both states in the system).
    \item $\Box[Next]_{vars}$ is a \textit{box-action formula}, where
    \textit{Next} is an action and \textit{vars} is a state function.
    \item $\Box$ operator asserts the formula is always true for every step in the behaviour.
    \item And steps in the behaviour is defined as $[Next]_{vars}$, where $Next$
    describe the action and $vars$ capturing all variables representing the state.
\end{itemize}

%  $,  The formula is true iff every
% successive pair of steps in behaviour is a $[Next]_{vars}$. Finally $Spec$ is
% conjunction between $Init$ and $\Box[Next]_{vars}$. Note \textbf{all} TLA+
% specification follows very similar template. There are situation we will need to
% provide \textit{fairness} description - this will be covered later. \newline

\section{Safety}

Safety property describes invariant that must hold true in every state of
system. A common invariant is \textit{type safety} checks. In a digital clock, 
hour can only be in value between 0 to 23, and minute can only be value of 0 to 59:\newline

\begin{tla}
    Type_OK == 
        /\ hour \in 0..23
        /\ minute \in 0..59
\end{tla}
\begin{tlatex}
\@x{\@s{16.4} Type\_OK \.{\defeq}}%
\@x{\@s{32.8} \.{\land} hour \.{\in} 0 \.{\dotdot} 23}%
\@x{\@s{32.8} \.{\land} minute \.{\in} 0 \.{\dotdot} 59}%
\end{tlatex}

\section{Liveness}

Liveness property verifies certain behavioural across a sequence of state. One
liveness property can be confirming the clock wraps around correctly at
midnight (which involves mutliple states): \newline

\begin{tla}
    Liveness ==
        /\ hour = 23 /\ minute = 59 ~> hour = 0 /\ minute = 0
\end{tla}
\begin{tlatex}
\@x{\@s{16.4} Liveness \.{\defeq}}%
 \@x{\@s{32.8} \.{\land} hour \.{=} 23 \.{\land} minute \.{=} 59 \.{\leadsto}
 hour \.{=} 0 \.{\land} minute \.{=} 0}%
\end{tlatex}
\newline

$\leadsto$ is the \textit{leads to} operator, suggesting something is eventually
true. TLA+ provides a set of formulas that can be used to describe liveness
property.\newline 

To verify liveness, we need to modify the spec slightly to enable
\textit{fairness} to prevent \textit{stuttering}. In plain terms, fairness
ensure \textit{something} always happen in every step, allowing the states to
transition. Without fairness the spec is allowed to \textit{do nothing} as next
step, this means liveness condition may fail because the spec permits the system
to do nothing in perpetuity as next state. Fairness will be covered in more
detailed in later chapter.\newline

\begin{tla}
    Spec ==
        /\ Init
        /\ [][Next]_vars
        /\ WF_vars(Next)
\end{tla}
\begin{tlatex}
\@x{\@s{16.4} Spec \.{\defeq}}%
\@x{\@s{32.8} \.{\land} Init}%
\@x{\@s{32.8} \.{\land} {\Box} [ Next ]_{ vars}}%
\@x{\@s{32.8} \.{\land} {\WF}_{ vars} ( Next )}%
\end{tlatex}
\newline

$WF_{vars}(Next)$ is the fairness qualifier.

% TODO: insert reference here to specifying systems 8.1 

\section{Model Checker}

The TLA+ spec can be verified using TLC model checker. The TLC model checker
runs the spec and verifies all configured safety and liveness properties are
satisfied during execution. To run TLC, we need two things:
\begin{itemize}
    \item clock.tla - the spec itself
    \item clock.cfg - the corresponding configuration file
\end{itemize}

For reference, clock.tla spec is listed below:

\begin{tla}
--------------------------- MODULE clock ----------------------------
EXTENDS Naturals
VARIABLES hour, minute
vars == <<hour, minute>>
Type_OK == 
    /\ hour \in 0..23
    /\ minute \in 0..59
Liveness ==
    /\ hour = 23 /\ minute = 59 ~> hour = 0 /\ minute = 0
Init ==
    /\ hour = 0
    /\ minute = 0
NextMinute ==
    /\ minute = 59 
    /\ hour' = (hour + 1) % 24
    /\ minute' = 0
NextHour == 
    /\ minute # 59
    /\ hour' = hour 
    /\ minute' = minute + 1 
Next ==
    \/ NextMinute
    \/ NextHour
Spec ==
  /\ Init
  /\ [][Next]_vars
  /\ WF_vars(Next)
=============================================================================
\end{tla}
\begin{tlatex}
\@x{}\moduleLeftDash\@xx{ {\MODULE} clock}\moduleRightDash\@xx{}%
\@x{ {\EXTENDS} Naturals}%
\@x{ {\VARIABLES} hour ,\, minute}%
\@x{ vars \.{\defeq} {\langle} hour ,\, minute {\rangle}}%
\@x{ Type\_OK \.{\defeq}}%
\@x{\@s{16.4} \.{\land} hour \.{\in} 0 \.{\dotdot} 23}%
\@x{\@s{16.4} \.{\land} minute \.{\in} 0 \.{\dotdot} 59}%
\@x{ Liveness \.{\defeq}}%
 \@x{\@s{16.4} \.{\land} hour \.{=} 23 \.{\land} minute \.{=} 59 \.{\leadsto}
 hour \.{=} 0 \.{\land} minute \.{=} 0}%
\@x{ Init \.{\defeq}}%
\@x{\@s{16.4} \.{\land} hour \.{=} 0}%
\@x{\@s{16.4} \.{\land} minute \.{=} 0}%
\@x{ NextMinute \.{\defeq}}%
\@x{\@s{16.4} \.{\land} minute \.{=} 59}%
\@x{\@s{16.4} \.{\land} hour \.{'} \.{=} ( hour \.{+} 1 ) \.{\%} 24}%
\@x{\@s{16.4} \.{\land} minute \.{'} \.{=} 0}%
\@x{ NextHour \.{\defeq}}%
\@x{\@s{16.4} \.{\land} minute \.{\neq} 59}%
\@x{\@s{16.4} \.{\land} hour \.{'} \.{=} hour}%
\@x{\@s{16.4} \.{\land} minute \.{'} \.{=} minute \.{+} 1}%
\@x{ Next \.{\defeq}}%
\@x{\@s{16.4} \.{\lor} NextMinute}%
\@x{\@s{16.4} \.{\lor} NextHour}%
\@x{ Spec \.{\defeq}}%
\@x{\@s{8.2} \.{\land}\@s{0.16} Init}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\Box} [ Next ]_{ vars}}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\WF}_{ vars} ( Next )}%
\@x{}\bottombar\@xx{}%
\end{tlatex}

The corresponding clock.cfg is listed below: 
\begin{lstlisting}
    SPECIFICATION Spec
    INVARIANTS Type_OK
    PROPERTIES Liveness
\end{lstlisting}

Now run TLC and one should see something like this: 
\begin{lstlisting}
Model checking completed. No error has been found.
...
The depth of the complete state graph search is 1440.
\end{lstlisting}

\part{Examples}

\chapter{Blinking LED}

Let's start with a trivial specification of a blinking LED. The intent of this example 
is to demonstrate the core functionalities of TLA+ specification language.

TODO: briefly talk about tla+ and model checker here.

\section{Requirement}

The LED is represented by a boolean variable that can be either 0 or 1.\newline

... that's it.

\section{Spec}

The specification language may appear alienating as it is mathematically
motivated based on propositional logic. Despite the (possibly) daunting syntax,
designer only need to be familiar with a handful of key operators to start
realizing value using TLA+. This chapter will attempt to describe the example in
exhaustive detail to reduce the learning curve.

The following describe the core portion of the blinking LED spec. 

\begin{tla}
--------------------------- MODULE blinking ----------------------------
VARIABLES b 
vars == <<b>>
Init ==
    /\ b = 0
On == 
    /\ b = 0
    /\ b' = 1
Off == 
    /\ b = 1
    /\ b' = 0
Next ==
    \/ Off 
    \/ On
Spec ==
    /\ Init
    /\ [][Next]_vars
========
\end{tla}
\begin{tlatex}
\@x{}\moduleLeftDash\@xx{ {\MODULE} blinking}\moduleRightDash\@xx{}%
\@x{ {\VARIABLES} b}%
\@x{ vars \.{\defeq} {\langle} b {\rangle}}%
\@x{ Init\@s{2.02} \.{\defeq}}%
\@x{\@s{16.4} \.{\land} b \.{=} 0}%
\@x{ On \.{\defeq}}%
\@x{\@s{18.15} \.{\land} b \.{=} 0}%
\@x{\@s{18.15} \.{\land} b \.{'} \.{=} 1}%
\@x{ Off \.{\defeq}}%
\@x{\@s{15.91} \.{\land} b \.{=} 1}%
\@x{\@s{15.91} \.{\land} b \.{'} \.{=} 0}%
\@x{ Next \.{\defeq}}%
\@x{\@s{16.4} \.{\lor} Off}%
\@x{\@s{16.4} \.{\lor} On}%
\@x{ Spec \.{\defeq}}%
\@x{\@s{16.4} \.{\land} Init}%
\@x{\@s{16.4} \.{\land} {\Box} [ Next ]_{ vars}}%
\@x{}\bottombar\@xx{}%
\end{tlatex}

\begin{itemize}
    \item $\defeq$ is the \textit{defines equal} operator 
    \item $\land$ and $\lor$ are the AND and OR operator. The effect
    of these operator follow the natural definition in English: 
    \begin{itemize}
        \item $C \defeq A \land B$: C is true iff A and B are true
        \item $C \defeq A \lor B$: C is true iff A or B is true
    \end{itemize}
    \item The $'$ operator represents the next state. $b'$ represent b's next state. 
    \item $VARIABLES$ keyword defines a list of variables for the spec. In this case 
    the spec defines a variable $b$ which can be either 0 or 1
    \item $vars$ is typically defined as a shorthand to refer to \textit{all}
    variables in the spec. 
\end{itemize}

With the above definition, we can revisit the Action definitions: $Init$ defines
the initial system state, where b is set to 0.\newline 

$Next$ requires more elaboration. TLA+ specifies the system as a collection of
states with transitions between them. In a simplified sense, the state is
described as a collection of ANDs (eg. system is in state C if both A and B are
true), the ORs then describe the states the system can possibly be in (eg.
system can be in state C OR D). Revisiting the example, the blinking LED has two
states:
\begin{itemize}
    \item $On \defeq b = 0 \land b' = 1$: b switches on 
    \item $Off \defeq = 1 \land b' = 0$: b switches off
\end{itemize}

The system's $Next$ state is defined to be one of these states:\newline
$Next \defeq On \lor Off$.\newline

$\Box[Next]_{vars}$ is a \textbf{Box-Action Formula}, where \textit{Next} is an
action and \textit{vars} is a state function. The formula is true iff every
successive pair of steps in behaviour is a $[Next]_{vars}$. Finally $Spec$ is
conjunction between $Init$ and $\Box[Next]_{vars}$. Note \textbf{all} TLA+
specification follows very similar template. There are situation we will need to
provide \textit{fairness} description - this will be covered later. \newline

In short: this specification describes a two-state state machine where b toggles
between 0 and 1.\newline

Note that b can technically be \textit{anything}. b can be 0, 1, -42, a
dinosaur, etc. TLA+ specifies values of $b$ which are valid in the system.

\section{Safety}

The spec so far only defines the possible states - but the \textit{power} of
TLA+ lies in its \textit{properties} description. Safety properties are
invariants that must hold true in \textit{every} state. An invariant in the
blinking LED example is: 
\begin{tla}
    TypeOK == b \in {0, 1}
\end{tla}
\begin{tlatex}
\@x{\@s{16.4} TypeOK \.{\defeq} b \.{\in} \{ 0 ,\, 1 \}}%
\end{tlatex}

This states the only valid value of b is 0 or 1. If b is ever set to anything
else, the spec is invalid.\newline

Some example safety properties include: Only a single thread have exclusive
access to critical section, number of concurrent reads cannot exceed data
available to be read, etc. 

\section{Liveness}

While safety properties describe invariant that must be upheld in every state,
\textit{Liveness} describe properties of a sequence of states. In the blinking
LED example, a liveness property can be the if b is 0, it eventually becomes 1,
and vice versa. This is described below:
\begin{tla}
    Liveness == 
        /\ b = 0 ~> b = 1
        /\ b = 1 ~> b = 0
\end{tla}
\begin{tlatex}
\@x{\@s{16.4} Liveness \.{\defeq}}%
\@x{\@s{32.8} \.{\land} b \.{=} 0 \.{\leadsto} b \.{=} 1}%
\@x{\@s{32.8} \.{\land} b \.{=} 1 \.{\leadsto} b \.{=} 0}%
\end{tlatex}

It is the author's opinion liveness describes the \textit{design essense} behind
the spec. The key characteristic of a system is described by its
\textit{behaviour} across a series of states. Does a distribute algorithm
eventually converge to a working state? Does a resource manager fairly allocate
resources in all scenarios? Does a scheduler ensure all tasks are eventually
scheduled? These are behaviours that are \textit{cannot} be concluded by looking
at a single state, but across a \textit{sequence of state}. Liveness allows 
designer to express and verify these properties.

\section{Model Checking}

Since the blinking LED is trivially specified, the full specification is
included below. For subsequent chapters only snippet will be included. Please
refer to the accompanied material for full spec source. 

TODO: install toolchain 

TODO: commandline

TODO: using TLC

The following is the content of \textit{blinking.tla}:
\begin{tla}
--------------------------- MODULE blinking ----------------------------
EXTENDS Naturals
VARIABLES b 
vars == <<b>>
TypeOK ==
  /\ b \in {0, 1} 
Liveness == 
    /\ b = 0 ~> b = 1
    /\ b = 1 ~> b = 0
Init ==
  /\ b = 0
Next ==
  \/ /\ b = 0
     /\ b' = 1
  \/ /\ b = 1
     /\ b' = 0
Spec ==
  /\ Init
  /\ [][Next]_vars
  /\ WF_vars(Next)
=============================================================================
\end{tla}
\begin{tlatex}
\@x{}\moduleLeftDash\@xx{ {\MODULE} blinking}\moduleRightDash\@xx{}%
\@x{ {\EXTENDS} Naturals}%
\@x{ {\VARIABLES} b}%
\@x{ vars \.{\defeq} {\langle} b {\rangle}}%
\@x{ TypeOK \.{\defeq}}%
\@x{\@s{8.2} \.{\land} b \.{\in} \{ 0 ,\, 1 \}}%
\@x{ Liveness \.{\defeq}}%
\@x{\@s{16.4} \.{\land} b \.{=} 0 \.{\leadsto} b \.{=} 1}%
\@x{\@s{16.4} \.{\land} b \.{=} 1 \.{\leadsto} b \.{=} 0}%
\@x{ Init \.{\defeq}}%
\@x{\@s{8.2} \.{\land} b \.{=} 0}%
\@x{ Next \.{\defeq}}%
\@x{\@s{8.2} \.{\lor}\@s{1.63} \.{\land} b \.{=} 0}%
\@x{\@s{20.94} \.{\land} b \.{'} \.{=} 1}%
\@x{\@s{8.2} \.{\lor}\@s{1.63} \.{\land} b \.{=} 1}%
\@x{\@s{20.94} \.{\land} b \.{'} \.{=} 0}%
\@x{ Spec \.{\defeq}}%
\@x{\@s{8.2} \.{\land}\@s{0.16} Init}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\Box} [ Next ]_{ vars}}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\WF}_{ vars} ( Next )}%
\@x{}\bottombar\@xx{}%
\end{tlatex}

The following is the content of \textit{blinking.cfg}:

\begin{lstlisting}
    SPECIFICATION Spec
    INVARIANTS TypeOK
    PROPERTIES Liveness
\end{lstlisting}

\section{Limitation}

Since TLA+ exhaustively explores all possible state, a linear growth of
variables leads to TLC (temporal logic checker) execution time grows
\textit{exponentially}.This means the specification must be scoped correctly to
limit the state space.\newline

Similarly, if you want to verify concurrent psuedo code implementation in
PlusCal, you can likely at most verify 10s of lines of code.

\chapter{Simple Gossip Protocol}

This section the author's notes on a simple gossip protocol by Andrew Hewler:\newline
https://ahelwer.ca/post/2023-11-01-tla-finite-monotonic/\newline

\section{Requirement}

In a distributed system, a cluster of nodes collectively provide a serivce. A
distributed database may have a collection of 10s to 100s of nodes working
together to offer the service in a geo diverse fashion to be immnue to partial
outage.  The nodes often have requirements to know about each other. In the
context of distributed database, a node may need to know the key range another
of its peers. The cluster needs a way to communicate this information. One such
mechanism is the gossip protocol.\newline

Gossip protocols are used to communicate cluster information in a distributed
fashion, (unsurprisingly) in a distributed system. Without gossip protocol, 
nodes in a cluster learns about its neighbours by contacting a centralized
server. This introduces a single failure point in the system. As the name
suggest, gossip protocol relies on nodes to gossip with each other. The nodes in
the cluster periodically selects a set of neighbors to exchange what it knows
about the cluster. The recency information is part of the gossip message
itself, allowing the node and the peer its talking to quickly decide who has the
latest information on a node, and converge to it. Assume a N node cluster and
each interal a node selects k neighbours to gossip with, the total amount of
gossip propagation time is described logrithmticly below:

\begin{equation} 
    propagation\_time = \log_k N * gossip\_interval
\end{equation}

With the total number of messages exchanged: 
\begin{equation} 
    messages\_exchanged = \log_k N * k
\end{equation}

Now let's look at how a simple gossip protocol can be described by TLA+.

\section{Spec}

In gossip protocol, every node needs to remember all its peers current
version. This can be represented as a two dimension array:\newline
\begin{tla}
    Init == counter = [n \in Node |-> [o \in Node |-> 0]] 
\end{tla}
\begin{tlatex}
 \@x{\@s{16.4} Init \.{\defeq} counter \.{=} [ n \.{\in} Node \.{\mapsto} [ o
 \.{\in} Node \.{\mapsto} 0 ] ]}%
\end{tlatex}
\newline

This defines counter a collection of nodes, where each node also contains a
collection of nodes initialized to 0. The nodes can bump to a new version:\newline
\begin{tla}
    Increment(n) == counter' = [counter EXCEPT ![n][n] = @ + 1]
\end{tla}
\begin{tlatex}
 \@x{\@s{16.4} Increment ( n ) \.{\defeq} counter \.{'} \.{=} [ counter
 {\EXCEPT} {\bang} [ n ] [ n ] \.{=} @ \.{+} 1 ]}%
\end{tlatex}
\newline

Notice increment only bumps node's version. This change needs to be gossiped 
across the cluster:\newline
\begin{tla}
Gossip(n, o) ==                  
    LET Max(a, b) == IF a > b THEN a ELSE b 
    IN counter' = [
        counter EXCEPT ![o] = [
            nn \in Node |->            
                Max(counter[n][nn], counter[o][nn])
            ] 
    ]
\end{tla}
\begin{tlatex}
\@x{ Gossip ( n ,\, o ) \.{\defeq}}%
 \@x{\@s{16.4} \.{\LET} Max ( a ,\, b ) \.{\defeq} {\IF} a \.{>} b \.{\THEN} a
 \.{\ELSE} b}%
\@x{\@s{16.4} \.{\IN} counter \.{'} \.{=} [}%
\@x{\@s{40.89} counter {\EXCEPT} {\bang} [ o ] \.{=} [}%
\@x{\@s{57.29} nn \.{\in} Node \.{\mapsto}}%
\@x{\@s{73.41} Max ( counter [ n ] [ nn ] ,\, counter [ o ] [ nn ] )}%
\@x{\@s{57.29} ]}%
\@x{\@s{16.4} ]}%
\end{tlatex}
\newline

A few things to unpack here:
\begin{itemize}
    \item $n, o$ are the two nodes exchanging gossip. $o$ is the node to be updated
    and $n$ is the neighbor $o$ gossips with.
    \item $LET .. IN$ allows local definition under $LET$ used under
    $IN$. In this case $Max$ is a local macro defined to return maximum between a and b.
    \item $counter'$ (or refered to as counter \textit{prime}) is what the
    variable will be in the next state. TLA+ doesn't provide a way to update a
    variable in a collection, so the convention is to assign a new array to the variable. 
    \item $counter\ EXCEPT ![o] = [...]$ return $counter$ with $counter[o]$
    defined in the bracket. 
    \item where $[...]$ is a collection of nodes with with counter set to the
    max between the current node and neighbour.
\end{itemize}

Finally, the actual spec: \newline
\begin{tla}
    Next == \/ \E n \in Node : Increment(n)
            \/ \E n, o \in Node : Gossip(n, o)
\end{tla}
\begin{tlatex}
 \@x{\@s{16.4} Next \.{\defeq} \.{\lor} \E\, n \.{\in} Node \.{:} Increment (
 n )}%
\@x{\@s{56.23} \.{\lor} \E\, n ,\, o \.{\in} Node \.{:} Gossip ( n ,\, o )}%
\end{tlatex}
\newline

Next supports two possible next steps describe using disjunctions. The first is
bumping the version of a random node, the second is select a pair of nodes to
gossip. Note the \textit{existential qualifier} on both, which basically states
there exists a node n in nodes, or there exists a pair of nodes n, o in nodes,
respectively.\newline

There's a minor problem with the definition above. Gossip protocol, like many
converging protocols, have a \textit{monotonic increasing} requirement. On
failures, the protocol bumps the version, which increases monotonically. Since
TLA+ spec models the system as a graph, a monotonic increasing version number
means the state graph is \textit{infinitely large}. To put the specification back into
finite space, we can normalize the state:\newline

\begin{tla}
GarbageCollect ==
    LET SetMin(s) == CHOOSE e \in s : \A o \in s : e <= o IN
    LET Transpose == SetMin({counter[n][o] : n, o \in Node}) IN
        /\ counter' = [
            n \in Node |-> [
                o \in Node |-> counter[n][o] - Transpose
            ]
          ]
        /\ UNCHANGED converge
\end{tla}
\begin{tlatex}
\@x{ GarbageCollect \.{\defeq}}%
 \@x{\@s{16.4} \.{\LET} SetMin ( s ) \.{\defeq} {\CHOOSE} e \.{\in} s \.{:}
 \A\, o \.{\in} s \.{:} e \.{\leq} o \.{\IN}}%
 \@x{\@s{16.4} \.{\LET} Transpose\@s{0.58} \.{\defeq} SetMin ( \{ counter [ n
 ] [ o ] \.{:} n ,\, o \.{\in} Node \} ) \.{\IN}}%
\@x{\@s{36.79} \.{\land} counter \.{'} \.{=} [}%
\@x{\@s{52.01} n \.{\in} Node \.{\mapsto} [}%
 \@x{\@s{66.60} o \.{\in} Node \.{\mapsto} counter [ n ] [ o ] \.{-}
 Transpose}%
\@x{\@s{52.01} ]}%
\@x{\@s{44.99} ]}%
\@x{\@s{36.79} \.{\land} {\UNCHANGED} converge}%
\end{tlatex}
\newline

\textit{GarbageCollect} substracts every version value with set minimum. To
limit range of version value, the increment function is now updated to: \newline
\begin{tla}
Increment(n) ==
    /\ ~converge
    /\ counter[n][n] < Divergence
    /\ S!Increment(n)
    /\ UNCHANGED converge
\end{tla}
\begin{tlatex}
\@x{ Increment ( n ) \.{\defeq}}%
\@x{\@s{16.4} \.{\land} {\lnot} converge}%
\@x{\@s{16.4} \.{\land} counter [ n ] [ n ] \.{<} Divergence}%
\@x{\@s{16.4} \.{\land} S {\bang} Increment ( n )}%
\@x{\@s{16.4} \.{\land} {\UNCHANGED} converge}%
\end{tlatex}
\newline

Finally, the \textit{Next} is updated to the follow:\newline

\begin{tla}
Next ==
    \/ \E n \in Node : Increment(n)
    \/ \E n, o \in Node : Gossip(n, o)
    \/ Converge
    \/ GarbageCollect
\end{tla}
\begin{tlatex}
\@x{ Next \.{\defeq}}%
\@x{\@s{16.4} \.{\lor} \E\, n \.{\in} Node \.{:} Increment ( n )}%
\@x{\@s{16.4} \.{\lor} \E\, n ,\, o \.{\in} Node \.{:} Gossip ( n ,\, o )}%
\@x{\@s{16.4} \.{\lor} Converge}%
\@x{\@s{16.4} \.{\lor} GarbageCollect}%
\end{tlatex}

Note $GarbageCollect$ is a now part of possible state transition. We will
discuss $Converge$ later, as it is related to liveness check. Lastly:\newline

\begin{tla}
Fairness == \A n, o \in Node : WF_vars(Gossip(n, o))
Spec ==
    /\ Init
    /\ [][Next]_vars
    /\ Fairness
\end{tla}
\begin{tlatex}
 \@x{ Fairness \.{\defeq} \A\, n ,\, o \.{\in} Node \.{:} {\WF}_{ vars} (
 Gossip ( n ,\, o ) )}%
\@x{ Spec \.{\defeq}}%
\@x{\@s{16.4} \.{\land} Init}%
\@x{\@s{16.4} \.{\land} {\Box} [ Next ]_{ vars}}%
\@x{\@s{16.4} \.{\land} Fairness}%
\end{tlatex}
\newline

The \textit{Fairness} definition ensures Gossip runs between every pair of nodes
gossip.

\section{Safety}

In every state, counter[n][o] next must be larger than counter[n][o] current:\newline

\begin{tla}
Monotonic == \A n, o \in Node : counter'[n][o] >= counter[n][o] 
Monotonicity == [][
    \/ S!Monotonic
    \/ \A a, b, c, d \in Node :
        (counter'[a][b] - counter[a][b]) = (counter'[c][d] - counter[c][d])
]_vars
\end{tla}
\begin{tlatex}
 \@x{ Monotonic \.{\defeq} \A\, n ,\, o \.{\in} Node \.{:} counter \.{'} [ n ]
 [ o ] \.{\geq} counter [ n ] [ o ]}%
\@x{ Monotonicity \.{\defeq} {\Box} [}%
\@x{\@s{16.4} \.{\lor} S {\bang} Monotonic}%
\@x{\@s{16.4} \.{\lor} \A\, a ,\, b ,\, c ,\, d \.{\in} Node \.{:}}%
 \@x{\@s{31.61} ( counter \.{'} [ a ] [ b ] \.{-} counter [ a ] [ b ] ) \.{=}
 ( counter \.{'} [ c ] [ d ] \.{-} counter [ c ] [ d ] )}%
\@x{ ]_{ vars}}%
\end{tlatex}

\section{Liveness}

For liveness we want to check the version value across all nodes eventually
converge. \textit{Next} is updated to set Converge to true, which triggers the
liveness condition and ensure all pair of nodes eventually have the same
information. \newline

\begin{tla}
Convergence == \A n, o \in Node : counter[n] = counter[o]
Liveness == converge ~> S!Convergence
Converge ==
    /\ converge' = TRUE
    /\ UNCHANGED counter  
Next ==
  \/ \E n \in Node : Increment(n)
  \/ \E n, o \in Node : Gossip(n, o)
  \/ Converge
  \/ GarbageCollect
\end{tla}
\begin{tlatex}
 \@x{ Convergence \.{\defeq} \A\, n ,\, o \.{\in} Node \.{:} counter [ n ]
 \.{=} counter [ o ]}%
 \@x{ Liveness\@s{2.98} \.{\defeq} converge \.{\leadsto} S {\bang}
 Convergence}%
\@x{ Converge \.{\defeq}}%
\@x{\@s{16.4} \.{\land} converge \.{'} \.{=} {\TRUE}}%
\@x{\@s{16.4} \.{\land} {\UNCHANGED} counter}%
\@x{ Next \.{\defeq}}%
\@x{\@s{8.2} \.{\lor}\@s{1.63} \E\, n \.{\in} Node \.{:} Increment ( n )}%
 \@x{\@s{8.2} \.{\lor}\@s{1.63} \E\, n ,\, o \.{\in} Node \.{:} Gossip ( n ,\,
 o )}%
\@x{\@s{8.2} \.{\lor}\@s{1.63} Converge}%
\@x{\@s{8.2} \.{\lor}\@s{1.63} GarbageCollect}%
\end{tlatex}



\include{scheduler}

\include{raft}

\section{Requirement}

\section{Spec}

\begin{tla}
Init ==
    /\ lastHash = NoHash
    /\ distributedLedger = [n \in Node |-> [h \in Hash |-> NoBlock]]
    /\ received = [n \in Node |-> {}]
\end{tla}
\begin{tlatex}
\@x{ Init \.{\defeq}}%
\@x{\@s{16.4} \.{\land} lastHash \.{=} NoHash}%
 \@x{\@s{16.4} \.{\land} distributedLedger \.{=} [ n \.{\in} Node \.{\mapsto}
 [ h \.{\in} Hash \.{\mapsto} NoBlock ] ]}%
\@x{\@s{16.4} \.{\land} received \.{=} [ n \.{\in} Node \.{\mapsto} \{ \} ]}%
\end{tlatex}
\newline

\begin{itemize}
    \item Every node is a ledger in this system, initialized to NoBlock
    \item Every node's received set is initialized to nothing
\end{itemize}

\part{Examples with PlusCal}

\include{spsc}

\chapter{SPMC Lockless Queue}

\part{Language Reference}

\chapter{Data Structure}

% \includesvg[width=0.8\textwidth]{dummy} % Replace 'example' with the path to your .svg file without the extension



Like other languages, TLA+ provides its data structure. I assume the readers are
already familiar with common data structure, and this chapter will only focus on
the TLA+ language semantics. 

\section{Set}

This is the most common data structure used in TLA+ spec. The following is a few examples on
how a set can be used:\newline
\begin{tla}
a == {0, 1, 2}
b == {2, 3, 4}
c == a \union b         \* \{0, 1, 2, 3, 4\}
d == a \intersect b     \* \{2\}
e == \E x \in c: x > 3  \* TRUE - because 4 in c is bigger than 3
f == \E x \in c: x > 5  \* FALSE - nothing in c is bigger than 5
g == \A x \in c: x < 3  \* FALSE - not all elements in c are smaller than 3
h == \A x \in c: x < 5  \* TRUE - all elements in c are smaller than 3
i == {x \in c: x < 3}   \* \{0, 1, 2\} - all elementse less than 3
j == Cardinality(c)     \* 5 - the number of elements in c
k == c \ d              \* \{0, 1, 3, 4\} - c substracts d
\end{tla}
\begin{tlatex}
\@x{ a\@s{0.26} \.{\defeq} \{ 0 ,\, 1 ,\, 2 \}}%
\@x{ b\@s{0.91} \.{\defeq} \{ 2 ,\, 3 ,\, 4 \}}%
\@x{ c\@s{0.97} \.{\defeq} a \.{\cup} b\@s{48.73}}%
\@y{%
  \{0, 1, 2, 3, 4\}
}%
\@xx{}%
\@x{ d \.{\defeq} a \.{\cap} b\@s{48.73}}%
\@y{%
  \{2\}
}%
\@xx{}%
\@x{ e\@s{0.79} \.{\defeq} \E\, x \.{\in} c \.{:} x \.{>} 3\@s{6.87}}%
\@y{%
  TRUE - because 4 in c is bigger than 3
}%
\@xx{}%
\@x{ f\@s{0.95} \.{\defeq} \E\, x \.{\in} c \.{:} x \.{>} 5\@s{6.87}}%
\@y{%
  FALSE - nothing in c is bigger than 5
}%
\@xx{}%
\@x{ g\@s{0.65} \.{\defeq} \A\, x \.{\in} c \.{:} x \.{<} 3\@s{6.87}}%
\@y{%
  FALSE - not all elements in c are smaller than 3
}%
\@xx{}%
\@x{ h\@s{0.26} \.{\defeq} \A\, x \.{\in} c \.{:} x \.{<} 5\@s{6.87}}%
\@y{%
  TRUE - all elements in c are smaller than 3
}%
\@xx{}%
\@x{ i\@s{2.05} \.{\defeq} \{ x \.{\in} c \.{:} x \.{<} 3 \}\@s{8.2}}%
\@y{%
  \{0, 1, 2\} - all elementse less than 3
}%
\@xx{}%
\@x{ j\@s{1.63} \.{\defeq} Cardinality ( c )\@s{16.4}}%
\@y{%
  5 - the number of elements in c
}%
\@xx{}%
\@x{ k\@s{0.46} \.{\defeq} c \.{\,\backslash\,} d\@s{51.30}}%
\@y{%
  \{0, 1, 3, 4\} - c substracts d
}%
\@xx{}%
\end{tlatex}

\section{Tuple}

\begin{tla}
A == <<0, 1, 2>>                    
B == <<2, 3, 4>>
C == A \o B                         \* tuple: 0, 1, 2, 2, 3, 4
D == Len(C)                         \* 6
E == \A x \in 1..Len(C) : C[x] # 10 \* TRUE - every C[x] is not 10
                                    \* First tuple element is at index 1 (not 0)
F == \E x \in 1..Len(C) : C[x] = 2  \* TRUE - there exists a C[x] that is 2
G == {x \in 1..Len(C) : C[x] = 2}   \* \{3, 4\} - when index is 3 or 4, C[x] = 2
\end{tla}
\begin{tlatex}
\@x{ A\@s{1.17} \.{\defeq} {\langle} 0 ,\, 1 ,\, 2 {\rangle}}%
\@x{ B\@s{0.54} \.{\defeq} {\langle} 2 ,\, 3 ,\, 4 {\rangle}}%
\@x{ C \.{\defeq} A \.{\circ} B\@s{104.04}}%
\@y{%
  tuple: 0, 1, 2, 2, 3, 4
}%
\@xx{}%
\@x{ D\@s{0.11} \.{\defeq} Len ( C )\@s{95.84}}%
\@y{%
  6
}%
\@xx{}%
 \@x{ E\@s{0.62} \.{\defeq} \A\, x \.{\in} 1 \.{\dotdot} Len ( C ) \.{:} C [ x
 ] \.{\neq} 10}%
\@y{%
  TRUE - every C[x] is not 10
}%
\@xx{}%
\@x{\@s{158.36}}%
\@y{%
  First tuple element is at index 1 (not 0)
}%
\@xx{}%
 \@x{ F\@s{0.75} \.{\defeq} \E\, x \.{\in} 1 \.{\dotdot} Len ( C ) \.{:} C [ x
 ] \.{=} 2\@s{6.87}}%
\@y{%
  TRUE - there exists a C[x] that is 2
}%
\@xx{}%
 \@x{ G \.{\defeq} \{ x \.{\in} 1 \.{\dotdot} Len ( C ) \.{:} C [ x ] \.{=} 2
 \}\@s{2.22}}%
\@y{%
  \{3, 4\} - when index is 3 or 4, C[x] = 2
}%
\@xx{}%
\end{tlatex}

\chapter{Idiom}

Choose a x in set S such that for every Y in S x is smaller than y.
Finding minimum in set:\newline
\begin{tla}
    Min(S) == CHOOSE x \in S : \A y \in S : x <= y
\end{tla}
\begin{tlatex}
 \@x{\@s{16.4} Min ( S ) \.{\defeq} {\CHOOSE} x \.{\in} S \.{:} \A\, y \.{\in}
 S \.{:} x \.{\leq} y}%
\end{tlatex}
\newline

messages is an unordered map with untyped key and integer value:\newline

\begin{tla}
messages = [m \in {} |-> 0]
\end{tla}
\begin{tlatex}
\@x{ messages \.{=} [ m \.{\in} \{ \} \.{\mapsto} 0 ]}%
\end{tlatex}


\chapter{Fairness and Liveness}

For rigorous definition and proof, please refer to (TODO: citations). This
chapter focus on the application aspect of liveness and fairness and define an elevator 
spec that goes up and down.\newline

\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
  \node[state]  (q1)                {1F};
  \node[state]  (q2) [right of=q1]  {2F};
  \node[state]  (q3) [right of=q2]  {3F};
  \node[state]  (q4) [right of=q3]  {4F};

  \path[->]          (q1)  edge   [bend left=20]   node {} (q2);
  \path[->]          (q2)  edge   [bend left=20]   node {} (q1);

  \path[->]          (q2)  edge   [bend left=20]   node {} (q3);
  \path[->]          (q3)  edge   [bend left=20]   node {} (q2);

  \path[->]          (q3)  edge   [bend left=20]   node {} (q4);
  \path[->]          (q4)  edge   [bend left=20]   node {} (q3);

\end{tikzpicture}

\section{Liveness}

Consider the following elevator \textit{Spec}:
\begin{tla}
--------------------------- MODULE elevator ----------------------------
EXTENDS Integers
VARIABLES a
vars == <<a>>
TOP     == 4
BOTTOM  == 1
Init ==
    /\ a = BOTTOM
Up == 
    /\ a # TOP
    /\ a' = a + 1
Down == 
    /\ a # BOTTOM
    /\ a' = a - 1
Spec ==
  /\ Init
  /\ [][Up \/ Down]_a
=============================================================================
\end{tla}
\begin{tlatex}
\@x{}\moduleLeftDash\@xx{ {\MODULE} elevator}\moduleRightDash\@xx{}%
\@x{ {\EXTENDS} Integers}%
\@x{ {\VARIABLES} a}%
\@x{ vars \.{\defeq} {\langle} a {\rangle}}%
\@x{ TOP\@s{28.75} \.{\defeq} 4}%
\@x{ BOTTOM\@s{4.10} \.{\defeq} 1}%
\@x{ Init \.{\defeq}}%
\@x{\@s{16.4} \.{\land} a \.{=} BOTTOM}%
\@x{ Up \.{\defeq}}%
\@x{\@s{17.27} \.{\land} a \.{\neq} TOP}%
\@x{\@s{17.27} \.{\land} a \.{'} \.{=} a \.{+} 1}%
\@x{ Down \.{\defeq}}%
\@x{\@s{16.4} \.{\land} a \.{\neq} BOTTOM}%
\@x{\@s{16.4} \.{\land} a \.{'} \.{=} a \.{-} 1}%
\@x{ Spec \.{\defeq}}%
\@x{\@s{8.2} \.{\land}\@s{0.16} Init}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\Box} [ Up \.{\lor} Down ]_{ a}}%
\@x{}\bottombar\@xx{}%
\end{tlatex}

The building has a set of floors and the elevator can go either up or down. The
elevator keeps going up until it's the top floor, or keep going down until it's
the bottom floor. TLC will pass the \textit{Spec} as is.\newline

Let's introduce a liveness property. The elevator should always at least go 
to the second floor:\newline
\begin{tla}
Liveness == 
    /\ a = 1 ~> a = 2
\end{tla}
\begin{tlatex}
\@x{ Liveness \.{\defeq}}%
\@x{\@s{16.4} \.{\land} a \.{=} 1 \.{\leadsto} a \.{=} 2}%
\end{tlatex}
\newline

Running the \textit{Spec} against TLC will report a violation:

\begin{verbatim}
Error: Temporal properties were violated.
Error: The following behavior constitutes a counter-example:
State 1: <Initial predicate>
a = 1
State 2: Stuttering
\end{verbatim}

Since the \textit{Spec} permits \textit{suttering}, the state machine is allowed
to perpetually stay on 1F and \textit{never} go to 2F. This can be fixed by
introduce fairness description.

\section{Weak Fairness}

Weak fairness is defined as:\newline
\begin{equation} 
\Diamond\Box(ENABLED\langle A \rangle _v) \implies \Box\Diamond\langle A \rangle _v
\end{equation}
$ENABLED\langle A \rangle$ represents \textit{conditions required} for action A.
The above translates to: if conditions required for action A to occur is
\textit{eventually always} true, then action A will \textit{always eventually}
happen.\newline 

Without weak fairness defined, the elevator may \textit{stutter} at floor 1 and
never go to floor 2. Weak fairness states that if the conditions of an action is
\textit{eventually always} true (ie. elevator decides to stay on 1F but but
\textit{can} go up), the elevator \textit{always eventually} go up.\newline

\begin{tla}
Spec ==
  /\ Init
  /\ [][Down \/ Up]_a
  /\ WF_a(Down)
  /\ WF_a(Up)
\end{tla}
\begin{tlatex}
\@x{ Spec \.{\defeq}}%
\@x{\@s{8.2} \.{\land}\@s{0.16} Init}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\Box} [ Down \.{\lor} Up ]_{ a}}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\WF}_{ a} ( Down )}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\WF}_{ a} ( Up )}%
\end{tlatex}
\newline

Running the spec against TLC passes again. What if we want to verify the
elevator eventually always goes to the top, not just to 2F? Let's modify the
Liveness property again:\newline
\begin{tla}
Liveness == 
    /\ a = BOTTOM ~> a = TOP
\end{tla}
\begin{tlatex}
\@x{ Liveness \.{\defeq}}%
\@x{\@s{16.4} \.{\land} a \.{=} BOTTOM \.{\leadsto} a \.{=} TOP}%
\end{tlatex}
\newline

TLC now reports the following violation: 
\begin{verbatim}
Error: Temporal properties were violated.
Error: The following behavior constitutes a counter-example:
State 1: <Initial predicate>
a = 1
State 2: <Up line 10, col 5 to line 11, col 17 of module elevator>
a = 2
Back to state 1: <Down line 13, col 5 to line 14, col 17 of module elevator>
\end{verbatim}

TLC identified a case where the elevator is perpetually stuck going between 1F
and 2F, but never go to 3F. Weak fairness is no longer enough, because the the
elevator is not stuck on 2F repeatedly, but stuck going between 1F and 2F. This
is where we need strong fairness.

\section{Strong Fairness}

Strong fairness is defined as:\newline
\begin{equation} 
\Box\Diamond(ENABLED\langle A \rangle _v) \implies \Box\Diamond\langle A \rangle _v
\end{equation}
The difference between weak and strong fairness is the \textit{eventually
always} vs. \textit{always eventually}. \newline 

In weak fairness, once the state machine is stuck in a state forever, the state
machine always transition to a possible next state permitted by the spec (eg. if
the elevator is stuck on 1F but can go to 2F, it will). With strong fairness,
the elevator doesn't need to be stuck on 2F to go to 3F. If the elevator
\textit{always eventually} makes it to 2F, it \textit{eventually always} go to
3F.\newline 

Intuitively we are tempted to enable strong fairness like so: \newline
\begin{tla}
Spec ==
  /\ Init
  /\ [][Up \/ Down]_a
  /\ WF_a(Down)
  /\ SF_a(UP)
\end{tla}
\begin{tlatex}
\@x{ Spec \.{\defeq}}%
\@x{\@s{8.2} \.{\land}\@s{0.16} Init}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\Box} [ Up \.{\lor} Down ]_{ a}}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\WF}_{ a} ( Down )}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\SF}_{ a} ( UP )}%
\end{tlatex}
\newline 

However, TLC \textit{still} reports the same violation. What's going on?\newline

If we take a closer look at the enabling condition for \textit{Up}, it only
requires current floor to be not the \textit{top floor}. When the elevator is
stuck in a loop going Up and Down between 1F and 2F indefinitely, strong
fairness for Up is \textit{already satisfied}. What we really want is strong
fairness on \textit{Up} for \textit{every floor}, instead of \textit{any floor
except top floor}. So if elevator makes to 2F once, it will \textit{always
eventaully} go to 3F. If elevator makes to 3F once, it will \textit{always
eventaully} go to 4F, etc. The following is the change required:\newline

\begin{tla}
Spec ==
  /\ Init
  /\ [][Up \/ Down]_a
  /\ WF_a(Down)
  /\ \A f \in BOTTOM..TOP-1: 
    /\ WF_a(Up /\ f = a)
\end{tla}
\begin{tlatex}
\@x{ Spec \.{\defeq}}%
\@x{\@s{8.2} \.{\land}\@s{0.16} Init}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\Box} [ Up \.{\lor} Down ]_{ a}}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\WF}_{ a} ( Down )}%
 \@x{\@s{8.2} \.{\land}\@s{0.16} \A\, f \.{\in} BOTTOM \.{\dotdot} TOP \.{-} 1
 \.{:}}%
\@x{\@s{16.4} \.{\land} {\WF}_{ a} ( Up \.{\land} f \.{=} a )}%
\end{tlatex}
\newline

Once again with this change TLC will pass.

\chapter{Abstraction Guideline}

\chapter{Reference}

\begin{thebibliography}{9}

\bibitem{}
Srikumar Subramanian
\textit{https://sriku.org/posts/fairness-in-tlaplus/}, 2015

\bibitem{}
% https://www.cds.caltech.edu/~murray/courses/afrl-sp12/L3_ltl-24Apr12.pdf
Richard M. Murray, Nok Wongpiromsarn
\textit{Linear Temporal Logic, Lecture 3}, 2012

\bibitem{backblaze}
\textit{https://www.backblaze.com/blog/cloud-storage-durability/}

\bibitem{raft}
\textit{https://raft.github.io/raft.pdf}

\bibitem{raft_tla}
\textit{https://github.com/ongardie/raft.tla}

\end{thebibliography}

\chapter{Nano}

TODO: add this to reference\newline
https://content.nano.org/whitepaper/Nano\_Whitepaper\_en.pdf

\section{Requirement}

\section{Spec}

\begin{tla}
Init ==
    /\ lastHash = NoHash
    /\ distributedLedger = [n \in Node |-> [h \in Hash |-> NoBlock]]
    /\ received = [n \in Node |-> {}]
\end{tla}
\begin{tlatex}
\@x{ Init \.{\defeq}}%
\@x{\@s{16.4} \.{\land} lastHash \.{=} NoHash}%
 \@x{\@s{16.4} \.{\land} distributedLedger \.{=} [ n \.{\in} Node \.{\mapsto}
 [ h \.{\in} Hash \.{\mapsto} NoBlock ] ]}%
\@x{\@s{16.4} \.{\land} received \.{=} [ n \.{\in} Node \.{\mapsto} \{ \} ]}%
\end{tlatex}

\begin{itemize}
    \item Every node is a ledger in this system, initialized to NoBlock
    \item Every node's received set is initialized to empty set
\end{itemize}

\begin{tla}
Next ==
    \/ \E account \in PrivateKey : CreateGenesisBlock(account)
    \/ \E node \in Node : CreateBlock(node)
    \/ \E node \in Node : ProcessBlock(node)
\end{tla}
\begin{tlatex}
\@x{ Next \.{\defeq}}%
 \@x{\@s{16.4} \.{\lor} \E\, account \.{\in} PrivateKey \.{:}
 CreateGenesisBlock ( account )}%
\@x{\@s{16.4} \.{\lor} \E\, node \.{\in} Node \.{:} CreateBlock ( node )}%
\@x{\@s{16.4} \.{\lor} \E\, node \.{\in} Node \.{:} ProcessBlock ( node )}%
\end{tlatex}
\newline

PrivateKey represents the identity of the account, create the genesis block for
every account. Let us look at how a genesis block is created:\newline

\begin{tla}
HashOf(block) ==
  IF \E hash \in Hash : hashFunction[hash] = block
  THEN CHOOSE hash \in Hash : hashFunction[hash] = block
  ELSE CHOOSE hash \in Hash : hashFunction[hash] = N!NoBlock

CalculateHashImpl(block, oldLastHash, newLastHash) ==
  LET hash == HashOf(block) IN
  /\ newLastHash = hash
  /\ hashFunction' = [hashFunction EXCEPT ![hash] = block]

CreateGenesisBlock(privateKey) ==
    LET
        publicKey == KeyPair[privateKey]
        genesisBlock ==
            [type   |-> "genesis",
            account |-> publicKey,
            balance |-> GenesisBalance]
    IN
    /\ ~GenesisBlockExists
    /\ CalculateHash(genesisBlock, lastHash, lastHash')
    /\ distributedLedger' =
        LET signedGenesisBlock ==
            [block |-> genesisBlock,
            signature |-> SignHash(lastHash', privateKey)]
        IN
        [n \in Node |->
            [distributedLedger[n] EXCEPT
                ![lastHash'] = signedGenesisBlock]]
    /\ UNCHANGED received
\end{tla}
\begin{tlatex}
\@x{ HashOf ( block ) \.{\defeq}}%
 \@x{\@s{8.2} {\IF} \E\, hash \.{\in} Hash \.{:} hashFunction [ hash ] \.{=}
 block}%
 \@x{\@s{8.2} \.{\THEN} {\CHOOSE} hash \.{\in} Hash \.{:} hashFunction [ hash
 ] \.{=} block}%
 \@x{\@s{8.2} \.{\ELSE} {\CHOOSE} hash \.{\in} Hash \.{:} hashFunction [ hash
 ] \.{=} N {\bang} NoBlock}%
\@pvspace{8.0pt}%
\@x{ CalculateHashImpl ( block ,\, oldLastHash ,\, newLastHash ) \.{\defeq}}%
\@x{\@s{8.2} \.{\LET} hash \.{\defeq} HashOf ( block ) \.{\IN}}%
\@x{\@s{8.2} \.{\land} newLastHash \.{=} hash}%
 \@x{\@s{8.2} \.{\land} hashFunction \.{'} \.{=} [ hashFunction {\EXCEPT}
 {\bang} [ hash ] \.{=} block ]}%
\@pvspace{8.0pt}%
\@x{ CreateGenesisBlock ( privateKey ) \.{\defeq}}%
\@x{\@s{16.4} \.{\LET}}%
\@x{\@s{32.8} publicKey \.{\defeq} KeyPair [ privateKey ]}%
\@x{\@s{32.8} genesisBlock \.{\defeq}}%
\@x{\@s{49.19} [ type\@s{12.75} \.{\mapsto}\@w{genesis} ,\,}%
\@x{\@s{49.19} account \.{\mapsto} publicKey ,\,}%
\@x{\@s{49.19} balance\@s{1.73} \.{\mapsto} GenesisBalance ]}%
\@x{\@s{16.4} \.{\IN}}%
\@x{\@s{16.4} \.{\land} {\lnot} GenesisBlockExists}%
 \@x{\@s{16.4} \.{\land} CalculateHash ( genesisBlock ,\, lastHash ,\,
 lastHash \.{'} )}%
\@x{\@s{16.4} \.{\land} distributedLedger \.{'} \.{=}}%
\@x{\@s{31.61} \.{\LET} signedGenesisBlock \.{\defeq}}%
\@x{\@s{52.01} [ block \.{\mapsto} genesisBlock ,\,}%
 \@x{\@s{52.01} signature \.{\mapsto} SignHash ( lastHash \.{'} ,\, privateKey
 ) ]}%
\@x{\@s{31.61} \.{\IN}}%
\@x{\@s{31.61} [ n \.{\in} Node \.{\mapsto}}%
\@x{\@s{44.87} [ distributedLedger [ n ] {\EXCEPT}}%
\@x{\@s{59.95} {\bang} [ lastHash \.{'} ] \.{=} signedGenesisBlock ] ]}%
\@x{\@s{16.4} \.{\land} {\UNCHANGED} received}%
\end{tlatex}
\newline

Every account maintains its own chain of blocks. The first block in the account
chain is the genesis block. The genesis block contains the type, account name,
and genesis balance. The genesis block is then hashed and signed.


% \chapter{Nano Blockchain}

TODO: add this to reference\newline
https://content.nano.org/whitepaper/Nano\_Whitepaper\_en.pdf


\end{document}
