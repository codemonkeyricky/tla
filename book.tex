
\documentclass{report}

\usepackage{tlatex}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{comment}
\usepackage{fancyhdr}
\usepackage{amssymb}
\usepackage{inputenc}
\usepackage{svg}

\usepackage{tikz}
\usetikzlibrary{automata, positioning, arrows}


% !TeX spellcheck = en_GB 

% Configure fancyhdr
\pagestyle{fancy}
\fancyhf{} % Clear default header and footer

% Header settings
\fancyhead[L]{\nouppercase{\leftmark}} % Chapter number and title on the left
% \fancyhead[C]{Center Header}    % Centered header
\fancyhead[R]{\thepage}     % Right-aligned header

% Footer settings
% \fancyfoot[L]{Left Footer}      % Left-aligned footer
% \fancyfoot[C]{Page \thepage}    % Centered footer with page number
% \fancyfoot[R]{Right Footer}     % Right-aligned footer

% java -cp /home/richard/dev/tla2tex/tla2tools.jar  tla2tex.TeX  book.tex 

\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\title{Learning TLA+ by Examples}
\author{Richard Tang}
\date{\today}
\begin{document}
\maketitle
\tableofcontents

\part{Introduction}

\include{intro}

\include{primer}

\part{Examples}

\include{blinking}

\include{gossip}

\include{scheduler}

\include{sack}

\include{raft}

\part{Examples with PlusCal}

\include{spsc}

\include{spmc}

\part{Reference}

\include{ds}

\chapter{Idiom}

Choose a x in set S such that for every Y in S x is smaller than y.
Finding minimum in set:\newline
\begin{tla}
    Min(S) == CHOOSE x \in S : \A y \in S : x <= y
\end{tla}
\begin{tlatex}
 \@x{\@s{16.4} Min ( S ) \.{\defeq} {\CHOOSE} x \.{\in} S \.{:} \A\, y \.{\in}
 S \.{:} x \.{\leq} y}%
\end{tlatex}
\newline

messages is an unordered map with untyped key and integer value:\newline

\begin{tla}
messages = [m \in {} |-> 0]
\end{tla}
\begin{tlatex}
\@x{ messages \.{=} [ m \.{\in} \{ \} \.{\mapsto} 0 ]}%
\end{tlatex}

\include{fairness}




\chapter{Abstraction Guideline}

\chapter{Reference}

\begin{thebibliography}{9}

\bibitem{}
Srikumar Subramanian
\textit{https://sriku.org/posts/fairness-in-tlaplus/}, 2015

\bibitem{}
% https://www.cds.caltech.edu/~murray/courses/afrl-sp12/L3_ltl-24Apr12.pdf
Richard M. Murray, Nok Wongpiromsarn
\textit{Linear Temporal Logic, Lecture 3}, 2012

\bibitem{backblaze}
\textit{https://www.backblaze.com/blog/cloud-storage-durability/}

\bibitem{raft}
\textit{https://raft.github.io/raft.pdf}

\bibitem{raft_tla}
\textit{https://github.com/ongardie/raft.tla}

\end{thebibliography}

\chapter{Nano}

TODO: add this to reference\newline
https://content.nano.org/whitepaper/Nano\_Whitepaper\_en.pdf

\section{Requirement}

\section{Spec}

\begin{tla}
Init ==
    /\ lastHash = NoHash
    /\ distributedLedger = [n \in Node |-> [h \in Hash |-> NoBlock]]
    /\ received = [n \in Node |-> {}]
\end{tla}
\begin{tlatex}
\@x{ Init \.{\defeq}}%
\@x{\@s{16.4} \.{\land} lastHash \.{=} NoHash}%
 \@x{\@s{16.4} \.{\land} distributedLedger \.{=} [ n \.{\in} Node \.{\mapsto}
 [ h \.{\in} Hash \.{\mapsto} NoBlock ] ]}%
\@x{\@s{16.4} \.{\land} received \.{=} [ n \.{\in} Node \.{\mapsto} \{ \} ]}%
\end{tlatex}

\begin{itemize}
    \item Every node is a ledger in this system, initialized to NoBlock
    \item Every node's received set is initialized to empty set
\end{itemize}

\begin{tla}
Next ==
    \/ \E account \in PrivateKey : CreateGenesisBlock(account)
    \/ \E node \in Node : CreateBlock(node)
    \/ \E node \in Node : ProcessBlock(node)
\end{tla}
\begin{tlatex}
\@x{ Next \.{\defeq}}%
 \@x{\@s{16.4} \.{\lor} \E\, account \.{\in} PrivateKey \.{:}
 CreateGenesisBlock ( account )}%
\@x{\@s{16.4} \.{\lor} \E\, node \.{\in} Node \.{:} CreateBlock ( node )}%
\@x{\@s{16.4} \.{\lor} \E\, node \.{\in} Node \.{:} ProcessBlock ( node )}%
\end{tlatex}
\newline

PrivateKey represents the identity of the account, create the genesis block for
every account. Let us look at how a genesis block is created:\newline

\begin{tla}
HashOf(block) ==
  IF \E hash \in Hash : hashFunction[hash] = block
  THEN CHOOSE hash \in Hash : hashFunction[hash] = block
  ELSE CHOOSE hash \in Hash : hashFunction[hash] = N!NoBlock

CalculateHashImpl(block, oldLastHash, newLastHash) ==
  LET hash == HashOf(block) IN
  /\ newLastHash = hash
  /\ hashFunction' = [hashFunction EXCEPT ![hash] = block]

CreateGenesisBlock(privateKey) ==
    LET
        publicKey == KeyPair[privateKey]
        genesisBlock ==
            [type   |-> "genesis",
            account |-> publicKey,
            balance |-> GenesisBalance]
    IN
    /\ ~GenesisBlockExists
    /\ CalculateHash(genesisBlock, lastHash, lastHash')
    /\ distributedLedger' =
        LET signedGenesisBlock ==
            [block |-> genesisBlock,
            signature |-> SignHash(lastHash', privateKey)]
        IN
        [n \in Node |->
            [distributedLedger[n] EXCEPT
                ![lastHash'] = signedGenesisBlock]]
    /\ UNCHANGED received
\end{tla}
\begin{tlatex}
\@x{ HashOf ( block ) \.{\defeq}}%
 \@x{\@s{8.2} {\IF} \E\, hash \.{\in} Hash \.{:} hashFunction [ hash ] \.{=}
 block}%
 \@x{\@s{8.2} \.{\THEN} {\CHOOSE} hash \.{\in} Hash \.{:} hashFunction [ hash
 ] \.{=} block}%
 \@x{\@s{8.2} \.{\ELSE} {\CHOOSE} hash \.{\in} Hash \.{:} hashFunction [ hash
 ] \.{=} N {\bang} NoBlock}%
\@pvspace{8.0pt}%
\@x{ CalculateHashImpl ( block ,\, oldLastHash ,\, newLastHash ) \.{\defeq}}%
\@x{\@s{8.2} \.{\LET} hash \.{\defeq} HashOf ( block ) \.{\IN}}%
\@x{\@s{8.2} \.{\land} newLastHash \.{=} hash}%
 \@x{\@s{8.2} \.{\land} hashFunction \.{'} \.{=} [ hashFunction {\EXCEPT}
 {\bang} [ hash ] \.{=} block ]}%
\@pvspace{8.0pt}%
\@x{ CreateGenesisBlock ( privateKey ) \.{\defeq}}%
\@x{\@s{16.4} \.{\LET}}%
\@x{\@s{32.8} publicKey \.{\defeq} KeyPair [ privateKey ]}%
\@x{\@s{32.8} genesisBlock \.{\defeq}}%
\@x{\@s{49.19} [ type\@s{12.75} \.{\mapsto}\@w{genesis} ,\,}%
\@x{\@s{49.19} account \.{\mapsto} publicKey ,\,}%
\@x{\@s{49.19} balance\@s{1.73} \.{\mapsto} GenesisBalance ]}%
\@x{\@s{16.4} \.{\IN}}%
\@x{\@s{16.4} \.{\land} {\lnot} GenesisBlockExists}%
 \@x{\@s{16.4} \.{\land} CalculateHash ( genesisBlock ,\, lastHash ,\,
 lastHash \.{'} )}%
\@x{\@s{16.4} \.{\land} distributedLedger \.{'} \.{=}}%
\@x{\@s{31.61} \.{\LET} signedGenesisBlock \.{\defeq}}%
\@x{\@s{52.01} [ block \.{\mapsto} genesisBlock ,\,}%
 \@x{\@s{52.01} signature \.{\mapsto} SignHash ( lastHash \.{'} ,\, privateKey
 ) ]}%
\@x{\@s{31.61} \.{\IN}}%
\@x{\@s{31.61} [ n \.{\in} Node \.{\mapsto}}%
\@x{\@s{44.87} [ distributedLedger [ n ] {\EXCEPT}}%
\@x{\@s{59.95} {\bang} [ lastHash \.{'} ] \.{=} signedGenesisBlock ] ]}%
\@x{\@s{16.4} \.{\land} {\UNCHANGED} received}%
\end{tlatex}
\newline

Every account maintains its own chain of blocks. The first block in the account
chain is the genesis block. The genesis block contains the type, account name,
and genesis balance. The genesis block is then hashed and signed.


% \chapter{Nano Blockchain}

TODO: add this to reference\newline
https://content.nano.org/whitepaper/Nano\_Whitepaper\_en.pdf

\chapter{Debugging}

TODO: debug using -dump 
TODO: check for run away state 
TODO: look for low value states to trim


\end{document}
