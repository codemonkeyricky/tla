
\documentclass{report}

\usepackage{tlatex}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{comment}
\usepackage{fancyhdr}
\usepackage{amssymb}

% Configure fancyhdr
\pagestyle{fancy}
\fancyhf{} % Clear default header and footer

% Header settings
\fancyhead[L]{\nouppercase{\leftmark}} % Chapter number and title on the left
% \fancyhead[C]{Center Header}    % Centered header
\fancyhead[R]{\thepage}     % Right-aligned header

% Footer settings
% \fancyfoot[L]{Left Footer}      % Left-aligned footer
% \fancyfoot[C]{Page \thepage}    % Centered footer with page number
% \fancyfoot[R]{Right Footer}     % Right-aligned footer

% java -cp /home/richard/dev/tla2tex/tla2tools.jar  tla2tex.TeX  book.tex 

\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\title{More TLA+ Examples}
\author{Richard Tang}
\date{\today}
\begin{document}
\maketitle
\tableofcontents

\chapter{Introduction}

TODO: personal industry experience 

TODO: TLA+ was developed ahead of its time, and software complexity finally
caught up 

TODO: concurrent programming use case 

TODO: distributed system use case

TODO: exhaustively check the entire space

With diminishing return on vertical scaling, the industry now invest heavily
towards horizontal scaling. This shifts complexity from hardware to software
with solution such as distributed algorithms. However, distributed algorithms
are hard to get right. The system is now a cluster of independently operating
entities and need to somehow collectively offer the correct system behaviour. To
make matter worse, human cognition is inherently singled threaded. We are not
good at reasoning about parallel execution. The usual anti-pattern is to keep
bandaiding the solution until bug reports stop comming in - but how does anyone
know if the solution is actually \textit{correct by design}? To solve this
problem, we then must rely on tools to do the reasoning for us, entering TLA+.
\newline

TLA+ is a \textit{system specification language}, with the intent to describe
the system with implementation details removed. TLA+ allows designer to
describe the system as a sequence of states. The designer can expresses
transition condition from one state to another, describe invariants that must
hold true in every state and liveness properties that the overall system should
converge to. The key innovation of TLA+ is once the system is modeled as a
finite state machine, the states can be \textit{exhaustively} explored (via
breath-first-search) to ensure certain properties are held through out the
entire state space (either per state or a sequence of states).\newline

\chapter{TLA+ Primer}

\section{Design Intent}

The key insight into TLA+ is modelling a system as a state machine. A blinking
LED system can be described using a single variable with two states, LED being
on or off. A simple digital clock can be represented by two variables, hour and
minute and the number of possible states in a digital clock is $24 * 60 = 1440$.
For example, $10:01$ is the next state $10:00$ can transition to.  Extrapolating
further, Asssume an arbitrarily system described by N variables, each variable
having K possible values such arbitrary system can have up to $N^K$
state.\newline

For every specification, designer can specify \textit{safety} proerty (or
invariants) that must be true in \textit{every} states. For example, in any
state of the digital clock hour \textit{must} be between 0 to 23, or formally
described as $hour \in 0..23$.  Similarly, $minute \in 0..59$. More generic
invariant examples include: in any state, only one thread has exclusive access
to a critical region, all variables in the system are within allowable value,
the resource allocation manager never allocates more than available resources,
etc. \newline

Designer can also specify \textit{liveness} property. These are properties that
are satisfied by a \textit{sequence of state}. One liveness property for the
digital clock could be when the clock is $10:00$, it will eventually become
$11:00$ (\textit{$10:00$ leads to $11:00$}). More generic liveness property
include: a distributed system eventually converges, the scheduler eventually
schedules every tasks in the task queue, the resource allocation manager fairly
allocates resources, etc. \newline

TLC checks a TLA+ spec using \textit{breath-first search} algorithm to explore
\textit{all} states in the state machine and ensure safety and liveness
properties are upheld.

\section{Digital Clock}

TLA+ specifies the system using \textit{propositional logic}. In this example, 
we will specify a digital clock that has hour and minute. The clock increments 
one minute at a time, and wraps around at midnight (ie. 23:59 transitions to
00:00). The \textit{Init} state of such system can be described as: \newline
\begin{tla}
    Init ==
        /\ hour = 0
        /\ minute = 0
\end{tla}
\begin{tlatex}
\@x{\@s{16.4} Init \.{\defeq}}%
\@x{\@s{32.8} \.{\land} hour \.{=} 0}%
\@x{\@s{32.8} \.{\land} minute \.{=} 0}%
\end{tlatex}
 \newline

$\defeq$ is the \textit{defines equal} symbol and $\land$ is the \textit{logical
and} symbol. The above TLA+ syntax can be read as \textit{Init} state is defined
as both hour and minute are both 0.\newline

The spec also always include a $Next$ definition, an \textit{action formula}
describing how the system transition from one state to another. Action formula
contains \textit{primed} variables what happens to the variable in its next
state. The $Next$ action for the digital clock can be defined as:\newline

\begin{tla}
    NextHour ==
        /\ minute = 59 
        /\ hour' = (hour + 1) % 24
        /\ minute' = 0
    NextMinute == 
        /\ minute # 59
        /\ hour' = hour 
        /\ minute' = minute + 1 
    Next ==
        \/ NextMinute
        \/ NextHour
\end{tla}
\begin{tlatex}
\@x{\@s{16.4} NextHour \.{\defeq}}%
\@x{\@s{32.8} \.{\land} minute \.{=} 59}%
\@x{\@s{32.8} \.{\land} hour \.{'} \.{=} ( hour \.{+} 1 ) \.{\%} 24}%
\@x{\@s{32.8} \.{\land} minute \.{'} \.{=} 0}%
\@x{\@s{16.4} NextMinute \.{\defeq}}%
\@x{\@s{32.8} \.{\land} minute \.{\neq} 59}%
\@x{\@s{32.8} \.{\land} hour \.{'} \.{=} hour}%
\@x{\@s{32.8} \.{\land} minute \.{'} \.{=} minute \.{+} 1}%
\@x{\@s{16.4} Next \.{\defeq}}%
\@x{\@s{32.8} \.{\lor} NextMinute}%
\@x{\@s{32.8} \.{\lor} NextHour}%
\end{tlatex}
 \newline

Here's a breakdown of what the spec does:
\begin{itemize}
    \item $Next$ can take $NextMinute$ or $NextHour$
    \item $Next$ takes $NextMinute$ when $minute$ is not 59, next hour is hour, next minute is minute + 1. 
    \item $Next$ takes $NextHour$ when $minute$ is 59, next hour is (hour + 1) modulus 24, next minute set to 0
\end{itemize}

Technically it's possible for $Next$ to take both $NextMinute$ and $NextHour$.
This is not possible in this definition as $NextHour$ and $NextMinute$ are
defined in a \textit{mutually exlusively} fashion.\newline

Finally, the spec itself is formally defined as:\newline
\begin{tla}
    vars == <<hour, minute>>
    Spec ==
        /\ Init
        /\ [][Next]_vars
\end{tla}
\begin{tlatex}
\@x{\@s{16.4} vars\@s{0.63} \.{\defeq} {\langle} hour ,\, minute {\rangle}}%
\@x{\@s{16.4} Spec \.{\defeq}}%
\@x{\@s{32.8} \.{\land} Init}%
\@x{\@s{32.8} \.{\land} {\Box} [ Next ]_{ vars}}%
\end{tlatex}
\newline

$\Box[Next]_{vars}$ deserves some special attention:
\begin{itemize}
    \item $vars$ is defined to be \textit{all} variables in the spec. Different
    combination of these variables constitute the states of the system (eg.
    23:59 and 00:00 are both states in the system).
    \item $\Box[Next]_{vars}$ is a \textit{box-action formula}, where
    \textit{Next} is an action and \textit{vars} is a state function.
    \item $\Box$ operator asserts the formula is always true for every step in the behaviour.
    \item And steps in the behaviour is defined as $[Next]_{vars}$, where $Next$
    describe the action and $vars$ capturing all variables representing the state.
\end{itemize}

%  $,  The formula is true iff every
% successive pair of steps in behaviour is a $[Next]_{vars}$. Finally $Spec$ is
% conjunction between $Init$ and $\Box[Next]_{vars}$. Note \textbf{all} TLA+
% specification follows very similar template. There are situation we will need to
% provide \textit{fairness} description - this will be covered later. \newline

\subsection{Safety}

Safety property describes invariant that must hold true in every state of
system. A common invariant is \textit{type safety} checks. In a digital clock, 
hour can only be in value between 0 to 23, and minute can only be value of 0 to 59:\newline

\begin{tla}
    Type_OK == 
        /\ hour \in 0..23
        /\ minute \in 0..59
\end{tla}
\begin{tlatex}
\@x{\@s{16.4} Type\_OK \.{\defeq}}%
\@x{\@s{32.8} \.{\land} hour \.{\in} 0 \.{\dotdot} 23}%
\@x{\@s{32.8} \.{\land} minute \.{\in} 0 \.{\dotdot} 59}%
\end{tlatex}

\section{Liveness}

Liveness property verifies certain behavioural across a sequence of state. One
liveness property can be confirming the clock wraps around correctly at
midnight (which involves mutliple states): \newline

\begin{tla}
    Liveness ==
        /\ hour = 23 /\ minute = 59 ~> hour = 0 /\ minute = 0
\end{tla}
\begin{tlatex}
\@x{\@s{16.4} Liveness \.{\defeq}}%
 \@x{\@s{32.8} \.{\land} hour \.{=} 23 \.{\land} minute \.{=} 59 \.{\leadsto}
 hour \.{=} 0 \.{\land} minute \.{=} 0}%
\end{tlatex}
\newline

$\leadsto$ is the \textit{leads to} operator, which suggest something is
eventually true. TLA+ provides a set of formulas that can be used to describe
liveness property.\newline 

To verify liveness, we need to modify the spec slightly to enable
\textit{fairness} to prevent \textit{stuttering}. In plain terms, fairness
ensure \textit{something} always happen in every step, allowing the states to
transition. Without fairness the spec is allowed to \textit{do nothing} as next
step. This means the liveness condition may fail because the spec permits the
system to do nothing in perpetuity as a possible next state. Fairness will be
covered in more detailed in later chapter.\newline

\begin{tla}
    Spec ==
        /\ Init
        /\ [][Next]_vars
        /\ WF_vars(Next)
\end{tla}
\begin{tlatex}
\@x{\@s{16.4} Spec \.{\defeq}}%
\@x{\@s{32.8} \.{\land} Init}%
\@x{\@s{32.8} \.{\land} {\Box} [ Next ]_{ vars}}%
\@x{\@s{32.8} \.{\land} {\WF}_{ vars} ( Next )}%
\end{tlatex}
\newline

$WF_{vars}(Next)$ is the fairness qualifier.

% TODO: insert reference here to specifying systems 8.1 

\section{TLC Model Checker}

The TLA+ spec can be verified using TLC model checker. The TLC model checker
runs the spec and verifies all configured safety and liveness properties are
satisfied during execution. To run TLC, we need two things:
\begin{itemize}
    \item clock.tla - the spec itself
    \item clock.cfg - the corresponding configuration file
\end{itemize}

For reference, clock.tla spec is listed below:

\begin{tla}
--------------------------- MODULE clock ----------------------------
EXTENDS Naturals
VARIABLES hour, minute
vars == <<hour, minute>>
Type_OK == 
    /\ hour \in 0..23
    /\ minute \in 0..59
Liveness ==
    /\ hour = 23 /\ minute = 59 ~> hour = 0 /\ minute = 0
Init ==
    /\ hour = 0
    /\ minute = 0
NextMinute ==
    /\ minute = 59 
    /\ hour' = (hour + 1) % 24
    /\ minute' = 0
NextHour == 
    /\ minute # 59
    /\ hour' = hour 
    /\ minute' = minute + 1 
Next ==
    \/ NextMinute
    \/ NextHour
Spec ==
  /\ Init
  /\ [][Next]_vars
  /\ WF_vars(Next)
=============================================================================
\end{tla}
\begin{tlatex}
\@x{}\moduleLeftDash\@xx{ {\MODULE} clock}\moduleRightDash\@xx{}%
\@x{ {\EXTENDS} Naturals}%
\@x{ {\VARIABLES} hour ,\, minute}%
\@x{ vars \.{\defeq} {\langle} hour ,\, minute {\rangle}}%
\@x{ Type\_OK \.{\defeq}}%
\@x{\@s{16.4} \.{\land} hour \.{\in} 0 \.{\dotdot} 23}%
\@x{\@s{16.4} \.{\land} minute \.{\in} 0 \.{\dotdot} 59}%
\@x{ Liveness \.{\defeq}}%
 \@x{\@s{16.4} \.{\land} hour \.{=} 23 \.{\land} minute \.{=} 59 \.{\leadsto}
 hour \.{=} 0 \.{\land} minute \.{=} 0}%
\@x{ Init \.{\defeq}}%
\@x{\@s{16.4} \.{\land} hour \.{=} 0}%
\@x{\@s{16.4} \.{\land} minute \.{=} 0}%
\@x{ NextMinute \.{\defeq}}%
\@x{\@s{16.4} \.{\land} minute \.{=} 59}%
\@x{\@s{16.4} \.{\land} hour \.{'} \.{=} ( hour \.{+} 1 ) \.{\%} 24}%
\@x{\@s{16.4} \.{\land} minute \.{'} \.{=} 0}%
\@x{ NextHour \.{\defeq}}%
\@x{\@s{16.4} \.{\land} minute \.{\neq} 59}%
\@x{\@s{16.4} \.{\land} hour \.{'} \.{=} hour}%
\@x{\@s{16.4} \.{\land} minute \.{'} \.{=} minute \.{+} 1}%
\@x{ Next \.{\defeq}}%
\@x{\@s{16.4} \.{\lor} NextMinute}%
\@x{\@s{16.4} \.{\lor} NextHour}%
\@x{ Spec \.{\defeq}}%
\@x{\@s{8.2} \.{\land}\@s{0.16} Init}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\Box} [ Next ]_{ vars}}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\WF}_{ vars} ( Next )}%
\@x{}\bottombar\@xx{}%
\end{tlatex}

The corresponding clock.cfg is listed below: 
\begin{lstlisting}
    SPECIFICATION Spec
    INVARIANTS Type_OK
    PROPERTIES Liveness
\end{lstlisting}

Now run TLC and one should see something like this: 
\begin{lstlisting}
Model checking completed. No error has been found.
...
The depth of the complete state graph search is 1440.
\end{lstlisting}


\chapter{Blinking LED}

Let's start with a trivial specification of a blinking LED. The intent of this example 
is to demonstrate the core functionalities of TLA+ specification language.

TODO: briefly talk about tla+ and model checker here.

\section{Requirement}

The LED is represented by a boolean variable that can be either 0 or 1.\newline

... that's it.

\section{Spec}

The specification language may appear alienating as it is mathematically
motivated based on propositional logic. Despite the (possibly) daunting syntax,
designer only need to be familiar with a handful of key operators to start
realizing value using TLA+. This chapter will attempt to describe the example in
exhaustive detail to reduce the learning curve.

The following describe the core portion of the blinking LED spec. 

\begin{tla}
--------------------------- MODULE blinking ----------------------------
VARIABLES b 
vars == <<b>>
Init ==
    /\ b = 0
On == 
    /\ b = 0
    /\ b' = 1
Off == 
    /\ b = 1
    /\ b' = 0
Next ==
    \/ Off 
    \/ On
Spec ==
    /\ Init
    /\ [][Next]_vars
========
\end{tla}
\begin{tlatex}
\@x{}\moduleLeftDash\@xx{ {\MODULE} blinking}\moduleRightDash\@xx{}%
\@x{ {\VARIABLES} b}%
\@x{ vars \.{\defeq} {\langle} b {\rangle}}%
\@x{ Init\@s{2.02} \.{\defeq}}%
\@x{\@s{16.4} \.{\land} b \.{=} 0}%
\@x{ On \.{\defeq}}%
\@x{\@s{18.15} \.{\land} b \.{=} 0}%
\@x{\@s{18.15} \.{\land} b \.{'} \.{=} 1}%
\@x{ Off \.{\defeq}}%
\@x{\@s{15.91} \.{\land} b \.{=} 1}%
\@x{\@s{15.91} \.{\land} b \.{'} \.{=} 0}%
\@x{ Next \.{\defeq}}%
\@x{\@s{16.4} \.{\lor} Off}%
\@x{\@s{16.4} \.{\lor} On}%
\@x{ Spec \.{\defeq}}%
\@x{\@s{16.4} \.{\land} Init}%
\@x{\@s{16.4} \.{\land} {\Box} [ Next ]_{ vars}}%
\@x{}\bottombar\@xx{}%
\end{tlatex}

\begin{itemize}
    \item $\defeq$ is the \textit{defines equal} operator 
    \item $\land$ and $\lor$ are the AND and OR operator. The effect
    of these operator follow the natural definition in English: 
    \begin{itemize}
        \item $C \defeq A \land B$: C is true iff A and B are true
        \item $C \defeq A \lor B$: C is true iff A or B is true
    \end{itemize}
    \item The $'$ operator represents the next state. $b'$ represent b's next state. 
    \item $VARIABLES$ keyword defines a list of variables for the spec. In this case 
    the spec defines a variable $b$ which can be either 0 or 1
    \item $vars$ is typically defined as a shorthand to refer to \textit{all}
    variables in the spec. 
\end{itemize}

With the above definition, we can revisit the Action definitions: $Init$ defines
the initial system state, where b is set to 0.\newline 

$Next$ requires more elaboration. TLA+ specifies the system as a collection of
states with transitions between them. In a simplified sense, the state is
described as a collection of ANDs (eg. system is in state C if both A and B are
true), the ORs then describe the states the system can possibly be in (eg.
system can be in state C OR D). Revisiting the example, the blinking LED has two
states:
\begin{itemize}
    \item $On \defeq b = 0 \land b' = 1$: b switches on 
    \item $Off \defeq = 1 \land b' = 0$: b switches off
\end{itemize}

The system's $Next$ state is defined to be one of these states:\newline
$Next \defeq On \lor Off$.\newline

$\Box[Next]_{vars}$ is a \textbf{Box-Action Formula}, where \textit{Next} is an
action and \textit{vars} is a state function. The formula is true iff every
successive pair of steps in behaviour is a $[Next]_{vars}$. Finally $Spec$ is
conjunction between $Init$ and $\Box[Next]_{vars}$. Note \textbf{all} TLA+
specification follows very similar template. There are situation we will need to
provide \textit{fairness} description - this will be covered later. \newline

In short: this specification describes a two-state state machine where b toggles
between 0 and 1.\newline

Note that b can technically be \textit{anything}. b can be 0, 1, -42, a
dinosaur, etc. TLA+ specifies values of $b$ which are valid in the system.

\section{Safety}

The spec so far only defines the possible states - but the \textit{power} of
TLA+ lies in its \textit{properties} description. Safety properties are
invariants that must hold true in \textit{every} state. An invariant in the
blinking LED example is: 
\begin{tla}
    TypeOK == b \in {0, 1}
\end{tla}
\begin{tlatex}
\@x{\@s{16.4} TypeOK \.{\defeq} b \.{\in} \{ 0 ,\, 1 \}}%
\end{tlatex}

This states the only valid value of b is 0 or 1. If b is ever set to anything
else, the spec is invalid.\newline

Some example safety properties include: Only a single thread have exclusive
access to critical section, number of concurrent reads cannot exceed data
available to be read, etc. 

\section{Liveness}

While safety properties describe invariant that must be upheld in every state,
\textit{Liveness} describe properties of a sequence of states. In the blinking
LED example, a liveness property can be the if b is 0, it eventually becomes 1,
and vice versa. This is described below:
\begin{tla}
    Liveness == 
        /\ b = 0 ~> b = 1
        /\ b = 1 ~> b = 0
\end{tla}
\begin{tlatex}
\@x{\@s{16.4} Liveness \.{\defeq}}%
\@x{\@s{32.8} \.{\land} b \.{=} 0 \.{\leadsto} b \.{=} 1}%
\@x{\@s{32.8} \.{\land} b \.{=} 1 \.{\leadsto} b \.{=} 0}%
\end{tlatex}

It is the author's opinion liveness describes the \textit{design essense} behind
the spec. The key characteristic of a system is described by its
\textit{behaviour} across a series of states. Does a distribute algorithm
eventually converge to a working state? Does a resource manager fairly allocate
resources in all scenarios? Does a scheduler ensure all tasks are eventually
scheduled? These are behaviours that are \textit{cannot} be concluded by looking
at a single state, but across a \textit{sequence of state}. Liveness allows 
designer to express and verify these properties.

\section{Model Checking}

Since the blinking LED is trivially specified, the full specification is
included below. For subsequent chapters only snippet will be included. Please
refer to the accompanied material for full spec source. 

TODO: install toolchain 

TODO: commandline

TODO: using TLC

The following is the content of \textit{blinking.tla}:
\begin{tla}
--------------------------- MODULE blinking ----------------------------
EXTENDS Naturals
VARIABLES b 
vars == <<b>>
TypeOK ==
  /\ b \in {0, 1} 
Liveness == 
    /\ b = 0 ~> b = 1
    /\ b = 1 ~> b = 0
Init ==
  /\ b = 0
Next ==
  \/ /\ b = 0
     /\ b' = 1
  \/ /\ b = 1
     /\ b' = 0
Spec ==
  /\ Init
  /\ [][Next]_vars
  /\ WF_vars(Next)
=============================================================================
\end{tla}
\begin{tlatex}
\@x{}\moduleLeftDash\@xx{ {\MODULE} blinking}\moduleRightDash\@xx{}%
\@x{ {\EXTENDS} Naturals}%
\@x{ {\VARIABLES} b}%
\@x{ vars \.{\defeq} {\langle} b {\rangle}}%
\@x{ TypeOK \.{\defeq}}%
\@x{\@s{8.2} \.{\land} b \.{\in} \{ 0 ,\, 1 \}}%
\@x{ Liveness \.{\defeq}}%
\@x{\@s{16.4} \.{\land} b \.{=} 0 \.{\leadsto} b \.{=} 1}%
\@x{\@s{16.4} \.{\land} b \.{=} 1 \.{\leadsto} b \.{=} 0}%
\@x{ Init \.{\defeq}}%
\@x{\@s{8.2} \.{\land} b \.{=} 0}%
\@x{ Next \.{\defeq}}%
\@x{\@s{8.2} \.{\lor}\@s{1.63} \.{\land} b \.{=} 0}%
\@x{\@s{20.94} \.{\land} b \.{'} \.{=} 1}%
\@x{\@s{8.2} \.{\lor}\@s{1.63} \.{\land} b \.{=} 1}%
\@x{\@s{20.94} \.{\land} b \.{'} \.{=} 0}%
\@x{ Spec \.{\defeq}}%
\@x{\@s{8.2} \.{\land}\@s{0.16} Init}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\Box} [ Next ]_{ vars}}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\WF}_{ vars} ( Next )}%
\@x{}\bottombar\@xx{}%
\end{tlatex}

The following is the content of \textit{blinking.cfg}:

\begin{lstlisting}
    SPECIFICATION Spec
    INVARIANTS TypeOK
    PROPERTIES Liveness
\end{lstlisting}

\section{Limitation}

Since TLA+ exhaustively explores all possible state, a linear growth of
variables leads to TLC (temporal logic checker) execution time grows
\textit{exponentially}.This means the specification must be scoped correctly to
limit the state space.\newline

Similarly, if you want to verify concurrent psuedo code implementation in
PlusCal, you can likely at most verify 10s of lines of code.

\chapter{SPSC Lockfree Queue}

Single producer single consumer (SPSC) \textit{Lockfree} queue is a standard
data exchange queue between a producer and a consumer. The SPSC lockfree queue
promises data can exchange between producer and consumer in a \textit{lockfree}
fashion, suggesting all condition both producer and consumer can make
progress.\newline

Contrast to standard shared queues, a SPSC waitfree queue doesn't require the
use of a \textit{lock} (eg. mutex). The queue can be logically represented
fairly simply as:

\begin{lstlisting}
    template <typename T, ssize_t N>
    class cQueue<T> { 
        ssize_t rptr = 0; 
        ssize_t wptr = 0; 
        std::array<T, N> buffer;
        /* TODO: API definition below... */
    };
\end{lstlisting}

A real implementation need to account for memory ordering effects specific to
the architecture. For example, ARM has weak memory ordering model where
read/write may appear out of order between CPUs. In this chapter we will only
assume \textit{logical} execution where each command is issued sequentially
(even perceived across CPUs) to focus the discussion on TLA+.
\section{Requirement}

As mentioned in earlier section, a SPSC queue is represented by an array, a pair
of read write pointer. The implementation is (hopefully) descriptively trivial:

\begin{itemize}
    \item Two executing context, reader and writer
    \item Writer advances wtpr after writes
    \item Reader advances rtpr after reads
    \item If rtpr equals wptr, queue is empty
    \item If (wtpr + 1) \% N equals rptr, queue is full
\end{itemize}
% \newline

A possible implementation may look like below (not accounting for memory
ordering effects):
\begin{lstlisting}
    template <typename T, ssize_t N>
    class cQueue { 
        ssize_t rptr = 0;
        ssize_t wptr = 0; 
        std::array<T, N> buffer;

    public:
        bool read(T &v) { 
            /* queue empty check */
            if (rptr == wptr) { 
                return false;
            }
            /* data get */
            v = buffer[rptr]; 
            /* rtpr update */
            rptr = (rptr + 1) % N;
            return true;
        }

        bool write(const T &v) { 
            /* queue full check */
            if ((wptr + 1) % N == rptr) { 
                return false;
            }
            /* data write */
            buffer[wptr] = v;
            /* wptr update */
            wptr = (wptr + 1) % N;
            return true;
        }
    };
\end{lstlisting}

Since reader and writer execute in different context, the instructions in read
and write can interleave in \textit{any} way imaginable:
\begin{itemize}
    \item queue empty check can happen before or after queue full check
    \item data write happens immediately before data read
    \item ... so on and so forth
\end{itemize}

The key observations is that buffer[wtpr] is reserved by the producer.
buffer[wtpr] is either unused or being written to. In either case the reader is
not allowed to access it. Symmetric reasoning applies to rptr. This provides
the \textit{safety} to the design - but how do we verify this?\newline

This is where TLA+ can help us formally verify the design.

\section{Spec}

TLA+ specification can be writen using its native formal specification
language, or a C-like syntax called PlusCal (which transpiles down to itse
native form). In this example, I chose to implement the specification using
PlusCal, since the content to be verified is psuedo implementation. While it is
possible specify SPSC in native TLA+, it is the author's opinion that it is
more error prone in this case, each line is effective an individual state needs
to be modeled.\newline

The following is a snippet of the specification written in PlusCal, hopefully
intuitive to read:
\begin{ppcal}
procedure reader(i) 
variable 
begin
r_chk_empty:        if rptr = wptr then 
r_early_ret:            return;
                    end if;
r_read_buf:         assert buffer[rptr] # 0;
r_cs:               buffer[rptr] := 0;
r_upd_rtpr:         rptr := (rptr + 1) % N;
                    return;
end procedure; 

procedure writer(i) begin
w_chk_full:         if (wptr + 1) % N = rptr then 
w_early_ret:            return; 
                    end if;
w_write_buf:        assert buffer[wptr] = 0;
w_cs:               buffer[wptr] := wptr + 1000;
w_upd_wptr:         wptr := (wptr + 1) % N;
                    return;
end procedure; 
\end{ppcal}\newline
\begin{tlatex}
\@x{ {\p@procedure} reader ( i )}%
\@x{ {\p@variable}}%
\@x{ {\p@begin}}%
 \@x{ r\_chk\_empty\@s{.5}\textrm{:}\@s{3}\@s{28.7} {\p@if} rptr \.{=} wptr
 {\p@then}}%
 \@x{ r\_early\_ret\@s{.5}\textrm{:}\@s{3}\@s{51.39} {\p@return}
 {\p@semicolon}}%
\@x{\@s{91.60} {\p@end} {\p@if} {\p@semicolon}}%
 \@x{ r\_read\_buf\@s{.5}\textrm{:}\@s{3}\@s{36.83} {\p@assert} buffer [ rptr
 ] \.{\neq} 0 {\p@semicolon}}%
 \@x{ r\_cs\@s{.5}\textrm{:}\@s{3}\@s{66.02} buffer [ rptr ] \.{:=} 0
 {\p@semicolon}}%
 \@x{ r\_upd\_rtpr\@s{.5}\textrm{:}\@s{3}\@s{36.98} rptr \.{:=} ( rptr \.{+} 1
 ) \.{\%} N {\p@semicolon}}%
\@x{\@s{91.60} {\p@return} {\p@semicolon}}%
\@x{ {\p@end} {\p@procedure} {\p@semicolon}}%
\@pvspace{8.0pt}%
\@x{ {\p@procedure} writer ( i ) {\p@begin}}%
 \@x{ w\_chk\_full\@s{.5}\textrm{:}\@s{3}\@s{35.97} {\p@if} ( wptr \.{+} 1 )
 \.{\%} N \.{=} rptr {\p@then}}%
 \@x{ w\_early\_ret\@s{.5}\textrm{:}\@s{3}\@s{45.1} {\p@return}
 {\p@semicolon}}%
\@x{\@s{89.45} {\p@end} {\p@if} {\p@semicolon}}%
 \@x{ w\_write\_buf\@s{.5}\textrm{:}\@s{3}\@s{28.7} {\p@assert} buffer [ wptr
 ] \.{=} 0 {\p@semicolon}}%
 \@x{ w\_cs\@s{.5}\textrm{:}\@s{3}\@s{64.27} buffer [ wptr ] \.{:=} wptr \.{+}
 1000 {\p@semicolon}}%
 \@x{ w\_upd\_wptr\@s{.5}\textrm{:}\@s{3}\@s{32.8} wptr \.{:=} ( wptr \.{+} 1
 ) \.{\%} N {\p@semicolon}}%
\@x{\@s{92.28} {\p@return} {\p@semicolon}}%
\@x{ {\p@end} {\p@procedure} {\p@semicolon}}%
\end{tlatex}

Note each command starts with a \textit{label}, such as r\_chk\_empty. All the
actions associated with the label is assumed executed atomically. This is
reflected in the generated TLA+ code:
\begin{tla}
    r_chk_empty(self) == /\ pc[self] = "r_chk_empty"
                     /\ IF rptr = wptr
                           THEN /\ pc' = [pc EXCEPT ![self] = "r_early_ret"]
                           ELSE /\ pc' = [pc EXCEPT ![self] = "r_read_buf"]
                     /\ UNCHANGED << rptr, wptr, buffer, stack, i_, i >>
\end{tla}
\begin{tlatex}
 \@x{\@s{16.4} r\_chk\_empty ( self ) \.{\defeq} \.{\land} pc [ self ]
 \.{=}\@w{r\_chk\_empty}}%
\@x{\@s{97.45} \.{\land} {\IF} rptr \.{=} wptr}%
 \@x{\@s{120.71} \.{\THEN} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [
 self ] \.{=}\@w{r\_early\_ret} ]}%
 \@x{\@s{120.71} \.{\ELSE} \.{\land} pc \.{'} \.{=} [ pc {\EXCEPT} {\bang} [
 self ] \.{=}\@w{r\_read\_buf} ]}%
 \@x{\@s{97.45} \.{\land} {\UNCHANGED} {\langle} rptr ,\, wptr ,\, buffer ,\,
 stack ,\, i\_ ,\, i {\rangle}}%
\end{tlatex}

\section{Safety}

As mentioned before, safety properties need to hold true in every single state.
Some safety requirement we can enforce, for example:\newline

Reader and writer cannot access the same index at the same time:
\begin{equation}
    \sim ((pc[100] = "w\_cs") \land (pc[101] = "r\_cs") \land rptr = wptr)
\end{equation}

All unused index should be set to 0:
\begin{equation}
    \A kk \in unused : buffer[kk] = 0
\end{equation}

At any given moment, buffer[wtpr] may be unused or written. buffer[rptr] may be
unused or read:
\begin{tla}
    \/ Cardinality(to_be_read) + 1 = Cardinality(reading)
    \/ Cardinality(to_be_read)     = Cardinality(reading) + 1
    \/ Cardinality(to_be_read)     = Cardinality(reading)
\end{tla}
\begin{tlatex}
 \@x{\@s{16.4} \.{\lor} Cardinality ( to\_be\_read ) \.{+} 1 \.{=} Cardinality
 ( reading )}%
 \@x{\@s{16.4} \.{\lor} Cardinality ( to\_be\_read )\@s{17.22} \.{=}
 Cardinality ( reading ) \.{+} 1}%
 \@x{\@s{16.4} \.{\lor} Cardinality ( to\_be\_read )\@s{17.22} \.{=}
 Cardinality ( reading )}%
\end{tlatex}

\section{Liveness}

All indicies are eventually used:

\begin{tla}
    Liveness ==
    \A k \in 0..N-1:
    <>(buffer[k] # 0)
\end{tla}
\begin{tlatex}
\@x{\@s{16.4} Liveness \.{\defeq}}%
\@x{\@s{16.4} \A\, k \.{\in} 0 \.{\dotdot} N \.{-} 1 \.{:}}%
\@x{\@s{16.4} {\Diamond} ( buffer [ k ] \.{\neq} 0 )}%
\end{tlatex}

Unused index 0 becomes used, used index 0 becomes unused.
\begin{tla}
    Liveness2 ==
    /\ (buffer[0] = 0) ~> buffer[0] = 1000
    /\ (buffer[0] = 1000) ~> buffer[0] = 0
\end{tla}
\begin{tlatex}
\@x{\@s{16.4} Liveness2 \.{\defeq}}%
 \@x{\@s{16.4} \.{\land} ( buffer [ 0 ] \.{=} 0 ) \.{\leadsto} buffer [ 0 ]
 \.{=} 1000}%
 \@x{\@s{16.4} \.{\land} ( buffer [ 0 ] \.{=} 1000 ) \.{\leadsto} buffer [ 0 ]
 \.{=} 0}%
\end{tlatex}

\section{Configuration}

\chapter{SPMC Lockless Queue}

\chapter{Simple Gossip Protocol}

This section the author's notes on a simple gossip protocol by Andrew Hewler:\newline
https://ahelwer.ca/post/2023-11-01-tla-finite-monotonic/\newline

\section{Requirement}

In a distributed system, a cluster of nodes collectively provide a serivce. A
distributed database may have a collection of 10s to 100s of nodes working
together to offer the service in a geo diverse fashion to be immnue to partial
outage.  The nodes often have requirements to know about each other. In the
context of distributed database, a node may need to know the key range another
of its peers. The cluster needs a way to communicate this information. One such
mechanism is the gossip protocol.

Gossip protocols are used to communicate cluster information in a distributed
fashion, (unsurprisingly) in a distributed system. Without gossip protocol, 
nodes in a cluster learns about its neighbours by contacting a centralized
server. This introduces a single failure point in the system. As the name
suggest, gossip protocol relies on nodes to gossip with each other. The nodes in
the cluster periodically selects a set of neighbors to exchange what it knows
about the cluster. The recency information is part of the gossip message
itself, allowing the node and the peer its talking to quickly decide who has the
latest information on a node, and converge to it. Assume a N node cluster and
each interal a node selects k neighbours to gossip with, the total amount of
gossip propagation time is described logrithmticly below:

\begin{equation} 
    propagation\_time = \log_k N * gossip\_interval
\end{equation}

With the total number of messages exchanged: 
\begin{equation} 
    messages\_exchanged = \log_k N * k
\end{equation}

Now let's look at how a simple gossip protocol can be described by TLA+.

\section{Spec}

\subsection{Base}

In gossip protocol, every node needs to remember every other node's current
state. In programming language this is typically described as counter[][]. The following is
the equivalent in TLA+: 
\begin{tla}
    Init == counter = [n \in Node |-> [o \in Node |-> 0]] 
\end{tla}
\begin{tlatex}
 \@x{\@s{16.4} Init \.{\defeq} counter \.{=} [ n \.{\in} Node \.{\mapsto} [ o
 \.{\in} Node \.{\mapsto} 0 ] ]}%
\end{tlatex}

This defines counter a collection of nodes, where each node also contains a
collection of nodes initialized to 0.\newline

The nodes can move to a new version: 
\begin{tla}
    Increment(n) == counter' = [counter EXCEPT ![n][n] = @ + 1]
\end{tla}
\begin{tlatex}
 \@x{\@s{16.4} Increment ( n ) \.{\defeq} counter \.{'} \.{=} [ counter
 {\EXCEPT} {\bang} [ n ] [ n ] \.{=} @ \.{+} 1 ]}%
\end{tlatex}
 \newline\newline
Note only the n's version is incremented. Communicating the update is done by
the gossip action defined below:
\begin{tla}
Gossip(n, o) ==                  
    LET Max(a, b) == IF a > b THEN a ELSE b 
    IN counter' = [
        counter EXCEPT ![o] = [
            nn \in Node |->            
                Max(counter[n][nn], counter[o][nn])
            ] 
    ]
\end{tla}
\begin{tlatex}
\@x{ Gossip ( n ,\, o ) \.{\defeq}}%
 \@x{\@s{16.4} \.{\LET} Max ( a ,\, b ) \.{\defeq} {\IF} a \.{>} b \.{\THEN} a
 \.{\ELSE} b}%
\@x{\@s{16.4} \.{\IN} counter \.{'} \.{=} [}%
\@x{\@s{40.89} counter {\EXCEPT} {\bang} [ o ] \.{=} [}%
\@x{\@s{57.29} nn \.{\in} Node \.{\mapsto}}%
\@x{\@s{73.41} Max ( counter [ n ] [ nn ] ,\, counter [ o ] [ nn ] )}%
\@x{\@s{57.29} ]}%
\@x{\@s{16.4} ]}%
\end{tlatex}

A few things to unpack here:
\begin{itemize}
    \item $n, o$ are the two nodes exchanging gossip. $o$ is the node to be updated
    and $n$ is the neighbor $o$ gossips with.
    \item $LET .. IN$ allows local definition under $LET$ used under
    $IN$. In this case $Max$ is a local macro defined to return maximum between a and b.
    \item $counter'$ (or refered to as counter \textit{prime}) is what the
    variable will be in the next state. TLA+ doesn't provide a way to update a
    variable in a collection, so the convention is to assign a new array to the variable. 
    \item $counter\ EXCEPT ![o] = [...]$ return $counter$ with $counter[o]$
    defined in the bracket. 
    \item where $[...]$ is a collection of nodes with with counter set to the
    max between the current node and neighbour.
\end{itemize}

Finally, the actual spec: 
\begin{tla}
    Next == \/ \E n \in Node : Increment(n)
            \/ \E n, o \in Node : Gossip(n, o)
\end{tla}
\begin{tlatex}
 \@x{\@s{16.4} Next \.{\defeq} \.{\lor} \E\, n \.{\in} Node \.{:} Increment (
 n )}%
\@x{\@s{56.23} \.{\lor} \E\, n ,\, o \.{\in} Node \.{:} Gossip ( n ,\, o )}%
\end{tlatex}

Next supports two possible next steps describe using disjunctions. The first is
bumping the version of a random node, the second is select a pair of nodes to
gossip. Note the \textit{existential qualifier} on both, which basically states
there exists a node n in nodes, or there exists a pair of nodes n, o in nodes,
respectively.\newline

Finally, the actual spec definition:
\begin{tla}
    Spec == /\ Init
            /\ [][Next]_counter  
\end{tla}
\begin{tlatex}
\@x{\@s{16.4} Spec \.{\defeq} \.{\land} Init}%
\@x{\@s{54.76} \.{\land} {\Box} [ Next ]_{ counter}}%
\end{tlatex}

The second conjunction formula is a \textbf{Box-Action Formula}, where
\textit{Next} is an action and \textit{counter} is a state function. The formula
is true iff every successive pair of steps in behaviour is a $[Next]_{counter}$.
The spec defines a temporal theorem that is \textit{always true}. 

\subsection{Finitized}

There's a minor problem with the definition above. Gossip protocol, like many
converging protocols, have a \textit{monotonic increasing} requirement. On
failures, the protocol bumps the version, which increases monotonically. Since
TLA+ spec models the system as a graph, a monotonic increasing version number
means the graph is \textit{infinitely large}. To put the specification back into
finite space, we can normalize the state:\newline

\begin{tla}
GarbageCollect ==
    LET SetMin(s) == CHOOSE e \in s : \A o \in s : e <= o IN
    LET Transpose == SetMin({counter[n][o] : n, o \in Node}) IN
        /\ counter' = [
            n \in Node |-> [
                o \in Node |-> counter[n][o] - Transpose
            ]
          ]
        /\ UNCHANGED converge
\end{tla}
\begin{tlatex}
\@x{ GarbageCollect \.{\defeq}}%
 \@x{\@s{16.4} \.{\LET} SetMin ( s ) \.{\defeq} {\CHOOSE} e \.{\in} s \.{:}
 \A\, o \.{\in} s \.{:} e \.{\leq} o \.{\IN}}%
 \@x{\@s{16.4} \.{\LET} Transpose\@s{0.58} \.{\defeq} SetMin ( \{ counter [ n
 ] [ o ] \.{:} n ,\, o \.{\in} Node \} ) \.{\IN}}%
\@x{\@s{36.79} \.{\land} counter \.{'} \.{=} [}%
\@x{\@s{52.01} n \.{\in} Node \.{\mapsto} [}%
 \@x{\@s{66.60} o \.{\in} Node \.{\mapsto} counter [ n ] [ o ] \.{-}
 Transpose}%
\@x{\@s{52.01} ]}%
\@x{\@s{44.99} ]}%
\@x{\@s{36.79} \.{\land} {\UNCHANGED} converge}%
\end{tlatex}

$SetMin(s)$ implements standard TLA+ semantics to retrieve the minimum element
in the set. The definition can be read as \textit{choose an $e$ from $S$ such
that for every $o$ in $S$, $o$ is equal or bigger than $e$}. $Transpose$ is then
subsequently defined as the minimum value exist in counter. Finally, $counter'$
is updated such that \textit{every} elements substracts $Transpose$.


% The $CHOOSE$ operator is described in \textit{Specifying
% Systems} 16.1.2 and takes the following form: 
%     \begin{equation}
%         CHOOSE\ x \in S : p
%     \end{equation}
% The chosen $x$ has to satisfy condition $p$. 

The increment function is now updated to: 
\begin{tla}
    Increment(n) ==
        /\ ~converge
        /\ counter[n][n] < Divergence
        /\ S!Increment(n)
        /\ UNCHANGED converge
\end{tla}
\begin{tlatex}
\@x{\@s{16.4} Increment ( n ) \.{\defeq}}%
\@x{\@s{32.8} \.{\land} {\lnot} converge}%
\@x{\@s{32.8} \.{\land} counter [ n ] [ n ] \.{<} Divergence}%
\@x{\@s{32.8} \.{\land} S {\bang} Increment ( n )}%
\@x{\@s{32.8} \.{\land} {\UNCHANGED} converge}%
\end{tlatex}

The conjunction $counter[n][n] < Divergence$ limits the maximum counter value.
Finally, the Next action is updated to the follow:

\begin{tla}
    Next ==
        \/ \E n \in Node : Increment(n)
        \/ \E n, o \in Node : Gossip(n, o)
        \/ Converge
        \/ GarbageCollect
\end{tla}
\begin{tlatex}
\@x{\@s{16.4} Next \.{\defeq}}%
\@x{\@s{32.8} \.{\lor} \E\, n \.{\in} Node \.{:} Increment ( n )}%
\@x{\@s{32.8} \.{\lor} \E\, n ,\, o \.{\in} Node \.{:} Gossip ( n ,\, o )}%
\@x{\@s{32.8} \.{\lor} Converge}%
\@x{\@s{32.8} \.{\lor} GarbageCollect}%
\end{tlatex}

Note $GarbageCollect$ is a now part of possible state transition. We will
discuss $Converge$ later, as it is related to liveness check. Lastly: 

\begin{tla}
    Fairness == \A n, o \in Node : WF_vars(Gossip(n, o))
    Spec ==
        /\ Init
        /\ [][Next]_vars
        /\ Fairness
\end{tla}
\begin{tlatex}
 \@x{\@s{16.4} Fairness \.{\defeq} \A\, n ,\, o \.{\in} Node \.{:} {\WF}_{
 vars} ( Gossip ( n ,\, o ) )}%
\@x{\@s{16.4} Spec \.{\defeq}}%
\@x{\@s{32.8} \.{\land} Init}%
\@x{\@s{32.8} \.{\land} {\Box} [ Next ]_{ vars}}%
\@x{\@s{32.8} \.{\land} Fairness}%
\end{tlatex}

The $Fairness$ conjunction ensures Gossip runs between every pair of n and o. 

\chapter{Raft Consensus Protocol}

\chapter{OS Scheduler}

\chapter{Miscellaneous}

\end{document}
