
\documentclass{report}

\usepackage{tlatex}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{comment}
\usepackage{fancyhdr}
\usepackage{amssymb}
\usepackage{inputenc}
\usepackage{svg}

\usepackage{tikz}
\usetikzlibrary{automata, positioning, arrows}


% !TeX spellcheck = en_GB 

% Configure fancyhdr
\pagestyle{fancy}
\fancyhf{} % Clear default header and footer

% Header settings
\fancyhead[L]{\nouppercase{\leftmark}} % Chapter number and title on the left
% \fancyhead[C]{Center Header}    % Centered header
\fancyhead[R]{\thepage}     % Right-aligned header

% Footer settings
% \fancyfoot[L]{Left Footer}      % Left-aligned footer
% \fancyfoot[C]{Page \thepage}    % Centered footer with page number
% \fancyfoot[R]{Right Footer}     % Right-aligned footer

% java -cp /home/richard/dev/tla2tex/tla2tools.jar  tla2tex.TeX  book.tex 

\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\title{Learning TLA+ by Examples}
\author{Richard Tang}
\date{\today}
\begin{document}
\maketitle
\tableofcontents

\include{intro}

\include{primer}

\part{Examples}

\include{blinking}

\include{gossip}

\include{scheduler}

\include{sack}

\include{raft}

\part{Examples with PlusCal}

\include{spsc}

\include{spmc}

\part{Reference}

\chapter{Idiom}

Choose a x in set S such that for every Y in S x is smaller than y.
Finding minimum in set:\newline
\begin{tla}
    Min(S) == CHOOSE x \in S : \A y \in S : x <= y
\end{tla}
\begin{tlatex}
 \@x{\@s{16.4} Min ( S ) \.{\defeq} {\CHOOSE} x \.{\in} S \.{:} \A\, y \.{\in}
 S \.{:} x \.{\leq} y}%
\end{tlatex}
\newline

messages is an unordered map with untyped key and integer value:\newline

\begin{tla}
messages = [m \in {} |-> 0]
\end{tla}
\begin{tlatex}
\@x{ messages \.{=} [ m \.{\in} \{ \} \.{\mapsto} 0 ]}%
\end{tlatex}


\chapter{Fairness and Liveness}

For rigorous definition and proof, please refer to (TODO: citations). This
chapter focus on the application aspect of liveness and fairness and define an elevator 
spec that goes up and down.\newline

\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
  \node[state]  (q1)                {1F};
  \node[state]  (q2) [right of=q1]  {2F};
  \node[state]  (q3) [right of=q2]  {3F};
  \node[state]  (q4) [right of=q3]  {4F};

  \path[->]          (q1)  edge   [bend left=20]   node {} (q2);
  \path[->]          (q2)  edge   [bend left=20]   node {} (q1);

  \path[->]          (q2)  edge   [bend left=20]   node {} (q3);
  \path[->]          (q3)  edge   [bend left=20]   node {} (q2);

  \path[->]          (q3)  edge   [bend left=20]   node {} (q4);
  \path[->]          (q4)  edge   [bend left=20]   node {} (q3);

\end{tikzpicture}

\section{Liveness}

Consider the following elevator \textit{Spec}:
\begin{tla}
--------------------------- MODULE elevator ----------------------------
EXTENDS Integers
VARIABLES a
vars == <<a>>
TOP     == 4
BOTTOM  == 1
Init ==
    /\ a = BOTTOM
Up == 
    /\ a # TOP
    /\ a' = a + 1
Down == 
    /\ a # BOTTOM
    /\ a' = a - 1
Spec ==
  /\ Init
  /\ [][Up \/ Down]_a
=============================================================================
\end{tla}
\begin{tlatex}
\@x{}\moduleLeftDash\@xx{ {\MODULE} elevator}\moduleRightDash\@xx{}%
\@x{ {\EXTENDS} Integers}%
\@x{ {\VARIABLES} a}%
\@x{ vars \.{\defeq} {\langle} a {\rangle}}%
\@x{ TOP\@s{28.75} \.{\defeq} 4}%
\@x{ BOTTOM\@s{4.10} \.{\defeq} 1}%
\@x{ Init \.{\defeq}}%
\@x{\@s{16.4} \.{\land} a \.{=} BOTTOM}%
\@x{ Up \.{\defeq}}%
\@x{\@s{17.27} \.{\land} a \.{\neq} TOP}%
\@x{\@s{17.27} \.{\land} a \.{'} \.{=} a \.{+} 1}%
\@x{ Down \.{\defeq}}%
\@x{\@s{16.4} \.{\land} a \.{\neq} BOTTOM}%
\@x{\@s{16.4} \.{\land} a \.{'} \.{=} a \.{-} 1}%
\@x{ Spec \.{\defeq}}%
\@x{\@s{8.2} \.{\land}\@s{0.16} Init}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\Box} [ Up \.{\lor} Down ]_{ a}}%
\@x{}\bottombar\@xx{}%
\end{tlatex}

The building has a set of floors and the elevator can go either up or down. The
elevator keeps going up until it's the top floor, or keep going down until it's
the bottom floor. TLC will pass the \textit{Spec} as is.\newline

Let's introduce a liveness property. The elevator should always at least go 
to the second floor:\newline
\begin{tla}
Liveness == 
    /\ a = 1 ~> a = 2
\end{tla}
\begin{tlatex}
\@x{ Liveness \.{\defeq}}%
\@x{\@s{16.4} \.{\land} a \.{=} 1 \.{\leadsto} a \.{=} 2}%
\end{tlatex}
\newline

Running the \textit{Spec} against TLC will report a violation:

\begin{verbatim}
Error: Temporal properties were violated.
Error: The following behavior constitutes a counter-example:
State 1: <Initial predicate>
a = 1
State 2: Stuttering
\end{verbatim}

Since the \textit{Spec} permits \textit{suttering}, the state machine is allowed
to perpetually stay on 1F and \textit{never} go to 2F. This can be fixed by
introducing fairness description.

\section{Weak Fairness}

Weak fairness is defined as:\newline
\begin{equation} 
\Diamond\Box(ENABLED\langle A \rangle _v) \implies \Box\Diamond\langle A \rangle _v
\end{equation}
$ENABLED\langle A \rangle$ represents \textit{conditions required} for action A.
The above translates to: if conditions required for action A to occur is
\textit{eventually always} true, then action A will \textit{always eventually}
happen.\newline 

Without weak fairness defined, the elevator may \textit{stutter} at 1F and
never go to 2F. Weak fairness states that if the conditions of an action is
\textit{eventually always} true (ie. elevator decides to stay on 1F but 
\textit{can} go up), the elevator \textit{always eventually} go up.\newline

\begin{tla}
Spec ==
  /\ Init
  /\ [][Down \/ Up]_a
  /\ WF_a(Down)
  /\ WF_a(Up)
\end{tla}
\begin{tlatex}
\@x{ Spec \.{\defeq}}%
\@x{\@s{8.2} \.{\land}\@s{0.16} Init}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\Box} [ Down \.{\lor} Up ]_{ a}}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\WF}_{ a} ( Down )}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\WF}_{ a} ( Up )}%
\end{tlatex}
\newline

Running the spec against TLC passes again. What if we want to verify the
elevator eventually always goes to the top, not just to 2F? Let's modify the
Liveness property again:\newline
\begin{tla}
Liveness == 
    /\ a = BOTTOM ~> a = TOP
\end{tla}
\begin{tlatex}
\@x{ Liveness \.{\defeq}}%
\@x{\@s{16.4} \.{\land} a \.{=} BOTTOM \.{\leadsto} a \.{=} TOP}%
\end{tlatex}
\newline

TLC now reports the following violation: 
\begin{verbatim}
Error: Temporal properties were violated.
Error: The following behavior constitutes a counter-example:
State 1: <Initial predicate>
a = 1
State 2: <Up line 10, col 5 to line 11, col 17 of module elevator>
a = 2
Back to state 1: <Down line 13, col 5 to line 14, col 17 of module elevator>
\end{verbatim}

TLC identified a case where the elevator is perpetually stuck going between 1F
and 2F, but never go to 3F. Weak fairness is no longer enough, because the the
elevator is not stuck on 2F repeatedly, but stuck going between 1F and 2F. This
is where we need strong fairness.

\section{Strong Fairness}

Strong fairness is defined as:\newline
\begin{equation} 
\Box\Diamond(ENABLED\langle A \rangle _v) \implies \Box\Diamond\langle A \rangle _v
\end{equation}
The difference between weak and strong fairness is the \textit{eventually
always} vs. \textit{always eventually}. \newline 

In weak fairness, once the state machine is stuck in a state forever, the state
machine always transition to a possible next state permitted by the
\textit{Spec} (eg. if the elevator is stuck on 1F but can go to 2F, it will).
With strong fairness, the elevator doesn't need to be stuck on 2F to go to 3F.
If the elevator \textit{always eventually} makes it to 2F, it \textit{always
eventually} go to 3F.\newline 

Intuitively we are tempted to enable strong fairness like so: \newline
\begin{tla}
Spec ==
  /\ Init
  /\ [][Up \/ Down]_a
  /\ WF_a(Down)
  /\ SF_a(UP)
\end{tla}
\begin{tlatex}
\@x{ Spec \.{\defeq}}%
\@x{\@s{8.2} \.{\land}\@s{0.16} Init}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\Box} [ Up \.{\lor} Down ]_{ a}}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\WF}_{ a} ( Down )}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\SF}_{ a} ( UP )}%
\end{tlatex}
\newline 

However, TLC \textit{still} reports the same violation. What's going on?\newline

If we take a closer look at the enabling condition for \textit{Up}, it only
requires current floor to be not the \textit{top floor}. When the elevator is
stuck in a loop going Up and Down between 1F and 2F indefinitely, strong
fairness for Up is \textit{already satisfied}. What we really want is strong
fairness on \textit{Up} for \textit{every floor}, instead of \textit{any floor
except top floor}. So if elevator makes to 2F once, it will \textit{always
eventaully} go to 3F. If elevator makes to 3F once, it will \textit{always
eventaully} go to 4F, so on and so forth. The following is the change
required:\newline

\begin{tla}
Spec ==
  /\ Init
  /\ [][Up \/ Down]_a
  /\ WF_a(Down)
  /\ \A f \in BOTTOM..TOP-1: 
    /\ WF_a(Up /\ f = a)
\end{tla}
\begin{tlatex}
\@x{ Spec \.{\defeq}}%
\@x{\@s{8.2} \.{\land}\@s{0.16} Init}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\Box} [ Up \.{\lor} Down ]_{ a}}%
\@x{\@s{8.2} \.{\land}\@s{0.16} {\WF}_{ a} ( Down )}%
 \@x{\@s{8.2} \.{\land}\@s{0.16} \A\, f \.{\in} BOTTOM \.{\dotdot} TOP \.{-} 1
 \.{:}}%
\@x{\@s{16.4} \.{\land} {\WF}_{ a} ( Up \.{\land} f \.{=} a )}%
\end{tlatex}
\newline

Once again with this change TLC will pass.

\chapter{Abstraction Guideline}

\chapter{Reference}

\begin{thebibliography}{9}

\bibitem{}
Srikumar Subramanian
\textit{https://sriku.org/posts/fairness-in-tlaplus/}, 2015

\bibitem{}
% https://www.cds.caltech.edu/~murray/courses/afrl-sp12/L3_ltl-24Apr12.pdf
Richard M. Murray, Nok Wongpiromsarn
\textit{Linear Temporal Logic, Lecture 3}, 2012

\bibitem{backblaze}
\textit{https://www.backblaze.com/blog/cloud-storage-durability/}

\bibitem{raft}
\textit{https://raft.github.io/raft.pdf}

\bibitem{raft_tla}
\textit{https://github.com/ongardie/raft.tla}

\end{thebibliography}

\chapter{Nano}

TODO: add this to reference\newline
https://content.nano.org/whitepaper/Nano\_Whitepaper\_en.pdf

\section{Requirement}

\section{Spec}

\begin{tla}
Init ==
    /\ lastHash = NoHash
    /\ distributedLedger = [n \in Node |-> [h \in Hash |-> NoBlock]]
    /\ received = [n \in Node |-> {}]
\end{tla}
\begin{tlatex}
\@x{ Init \.{\defeq}}%
\@x{\@s{16.4} \.{\land} lastHash \.{=} NoHash}%
 \@x{\@s{16.4} \.{\land} distributedLedger \.{=} [ n \.{\in} Node \.{\mapsto}
 [ h \.{\in} Hash \.{\mapsto} NoBlock ] ]}%
\@x{\@s{16.4} \.{\land} received \.{=} [ n \.{\in} Node \.{\mapsto} \{ \} ]}%
\end{tlatex}

\begin{itemize}
    \item Every node is a ledger in this system, initialized to NoBlock
    \item Every node's received set is initialized to empty set
\end{itemize}

\begin{tla}
Next ==
    \/ \E account \in PrivateKey : CreateGenesisBlock(account)
    \/ \E node \in Node : CreateBlock(node)
    \/ \E node \in Node : ProcessBlock(node)
\end{tla}
\begin{tlatex}
\@x{ Next \.{\defeq}}%
 \@x{\@s{16.4} \.{\lor} \E\, account \.{\in} PrivateKey \.{:}
 CreateGenesisBlock ( account )}%
\@x{\@s{16.4} \.{\lor} \E\, node \.{\in} Node \.{:} CreateBlock ( node )}%
\@x{\@s{16.4} \.{\lor} \E\, node \.{\in} Node \.{:} ProcessBlock ( node )}%
\end{tlatex}
\newline

PrivateKey represents the identity of the account, create the genesis block for
every account. Let us look at how a genesis block is created:\newline

\begin{tla}
HashOf(block) ==
  IF \E hash \in Hash : hashFunction[hash] = block
  THEN CHOOSE hash \in Hash : hashFunction[hash] = block
  ELSE CHOOSE hash \in Hash : hashFunction[hash] = N!NoBlock

CalculateHashImpl(block, oldLastHash, newLastHash) ==
  LET hash == HashOf(block) IN
  /\ newLastHash = hash
  /\ hashFunction' = [hashFunction EXCEPT ![hash] = block]

CreateGenesisBlock(privateKey) ==
    LET
        publicKey == KeyPair[privateKey]
        genesisBlock ==
            [type   |-> "genesis",
            account |-> publicKey,
            balance |-> GenesisBalance]
    IN
    /\ ~GenesisBlockExists
    /\ CalculateHash(genesisBlock, lastHash, lastHash')
    /\ distributedLedger' =
        LET signedGenesisBlock ==
            [block |-> genesisBlock,
            signature |-> SignHash(lastHash', privateKey)]
        IN
        [n \in Node |->
            [distributedLedger[n] EXCEPT
                ![lastHash'] = signedGenesisBlock]]
    /\ UNCHANGED received
\end{tla}
\begin{tlatex}
\@x{ HashOf ( block ) \.{\defeq}}%
 \@x{\@s{8.2} {\IF} \E\, hash \.{\in} Hash \.{:} hashFunction [ hash ] \.{=}
 block}%
 \@x{\@s{8.2} \.{\THEN} {\CHOOSE} hash \.{\in} Hash \.{:} hashFunction [ hash
 ] \.{=} block}%
 \@x{\@s{8.2} \.{\ELSE} {\CHOOSE} hash \.{\in} Hash \.{:} hashFunction [ hash
 ] \.{=} N {\bang} NoBlock}%
\@pvspace{8.0pt}%
\@x{ CalculateHashImpl ( block ,\, oldLastHash ,\, newLastHash ) \.{\defeq}}%
\@x{\@s{8.2} \.{\LET} hash \.{\defeq} HashOf ( block ) \.{\IN}}%
\@x{\@s{8.2} \.{\land} newLastHash \.{=} hash}%
 \@x{\@s{8.2} \.{\land} hashFunction \.{'} \.{=} [ hashFunction {\EXCEPT}
 {\bang} [ hash ] \.{=} block ]}%
\@pvspace{8.0pt}%
\@x{ CreateGenesisBlock ( privateKey ) \.{\defeq}}%
\@x{\@s{16.4} \.{\LET}}%
\@x{\@s{32.8} publicKey \.{\defeq} KeyPair [ privateKey ]}%
\@x{\@s{32.8} genesisBlock \.{\defeq}}%
\@x{\@s{49.19} [ type\@s{12.75} \.{\mapsto}\@w{genesis} ,\,}%
\@x{\@s{49.19} account \.{\mapsto} publicKey ,\,}%
\@x{\@s{49.19} balance\@s{1.73} \.{\mapsto} GenesisBalance ]}%
\@x{\@s{16.4} \.{\IN}}%
\@x{\@s{16.4} \.{\land} {\lnot} GenesisBlockExists}%
 \@x{\@s{16.4} \.{\land} CalculateHash ( genesisBlock ,\, lastHash ,\,
 lastHash \.{'} )}%
\@x{\@s{16.4} \.{\land} distributedLedger \.{'} \.{=}}%
\@x{\@s{31.61} \.{\LET} signedGenesisBlock \.{\defeq}}%
\@x{\@s{52.01} [ block \.{\mapsto} genesisBlock ,\,}%
 \@x{\@s{52.01} signature \.{\mapsto} SignHash ( lastHash \.{'} ,\, privateKey
 ) ]}%
\@x{\@s{31.61} \.{\IN}}%
\@x{\@s{31.61} [ n \.{\in} Node \.{\mapsto}}%
\@x{\@s{44.87} [ distributedLedger [ n ] {\EXCEPT}}%
\@x{\@s{59.95} {\bang} [ lastHash \.{'} ] \.{=} signedGenesisBlock ] ]}%
\@x{\@s{16.4} \.{\land} {\UNCHANGED} received}%
\end{tlatex}
\newline

Every account maintains its own chain of blocks. The first block in the account
chain is the genesis block. The genesis block contains the type, account name,
and genesis balance. The genesis block is then hashed and signed.


% \chapter{Nano Blockchain}

TODO: add this to reference\newline
https://content.nano.org/whitepaper/Nano\_Whitepaper\_en.pdf

\chapter{Debugging}

TODO: debug using -dump 
TODO: check for run away state 
TODO: look for low value states to trim


\end{document}
